---
title: 'Python SDK'
description: 'Build workflows programmatically with the Python SDK'
---

# Python SDK for Workflows

The Python SDK provides a fluent builder API for defining and running multi-agent workflows.

## Installation

```bash
pip install agent-relay
```

## Quick Start

```python
from agent_relay import workflow, Models

result = (
    workflow("my-feature")
    .pattern("dag")
    .agent("planner", cli="claude", model=Models.Claude.OPUS)
    .agent("developer", cli="codex", model=Models.Codex.CODEX_5_3)
    .step("plan", agent="planner", task="Create implementation plan")
    .step("implement", agent="developer", task="Build it", depends_on=["plan"])
    .run()
)

print(result.status)  # 'completed' or 'failed'
```

## Model Enums

Use type-safe model enums:

```python
from agent_relay import Models

# Claude models
Models.Claude.OPUS      # 'opus'
Models.Claude.SONNET    # 'sonnet'
Models.Claude.HAIKU     # 'haiku'

# Codex models
Models.Codex.CODEX_5_3  # 'gpt-5.3-codex'
Models.Codex.O3         # 'o3'
Models.Codex.O4_MINI    # 'o4-mini'

# Gemini models
Models.Gemini.PRO_2_5   # 'gemini-2.5-pro'
Models.Gemini.FLASH_2_5 # 'gemini-2.5-flash'
```

## Full Example: Feature Development

```python
from agent_relay import workflow, Models, SwarmPatterns

def build_feature(task: str):
    result = (
        workflow("feature-build")
        # Choose coordination pattern
        .pattern(SwarmPatterns.HUB_SPOKE)

        # Define agents with their CLIs and models
        .agent("lead",
            cli="claude",
            model=Models.Claude.OPUS,
            role="Technical lead who coordinates the team"
        )
        .agent("backend",
            cli="codex",
            model=Models.Codex.CODEX_5_3,
            role="Backend developer"
        )
        .agent("frontend",
            cli="claude",
            model=Models.Claude.SONNET,
            role="Frontend developer"
        )
        .agent("reviewer",
            cli="claude",
            model=Models.Claude.OPUS,
            role="Code reviewer"
        )

        # Define workflow steps with dependencies
        .step("plan",
            agent="lead",
            task=f"Break down this feature into tasks: {task}"
        )
        .step("backend_impl",
            agent="backend",
            task="Implement the backend based on: {{steps.plan.output}}",
            depends_on=["plan"]
        )
        .step("frontend_impl",
            agent="frontend",
            task="Implement the frontend based on: {{steps.plan.output}}",
            depends_on=["plan"]
        )
        .step("review",
            agent="reviewer",
            task="Review the implementation",
            depends_on=["backend_impl", "frontend_impl"]
        )
        .step("finalize",
            agent="lead",
            task="Finalize and merge based on review: {{steps.review.output}}",
            depends_on=["review"]
        )

        # Error handling
        .on_error("retry", max_retries=2, retry_delay_ms=5000)

        # Execute
        .run()
    )

    return result


# Run it
result = build_feature("Add user authentication with OAuth2")
print(f"Status: {result.status}")
print(f"Steps: {result.steps}")
```

## Workflow Builder API

### `workflow(name)`

Create a new workflow builder:

```python
from agent_relay import workflow

builder = workflow("my-workflow")
```

### `.pattern(pattern)`

Set the coordination pattern:

```python
from agent_relay import SwarmPatterns

builder.pattern(SwarmPatterns.DAG)        # Dependency-based execution
builder.pattern(SwarmPatterns.HUB_SPOKE)  # Central coordinator
builder.pattern(SwarmPatterns.FAN_OUT)    # Parallel execution
builder.pattern(SwarmPatterns.PIPELINE)   # Sequential stages
builder.pattern(SwarmPatterns.CONSENSUS)  # Voting/agreement
builder.pattern(SwarmPatterns.MESH)       # Full connectivity
```

### `.agent(name, **options)`

Define an agent:

```python
builder.agent("worker",
    cli="claude",                    # Required: claude, codex, gemini, cursor, aider, goose
    model=Models.Claude.SONNET,      # Optional: model to use
    role="Implements features",      # Optional: role description
    interactive=True,                # Optional: PTY mode (default: True)
    retries=2,                       # Optional: retry count
    timeout_ms=600000,               # Optional: timeout in ms
)
```

### `.step(name, **options)`

Define a workflow step:

```python
builder.step("implement",
    agent="worker",                  # Required: which agent runs this
    task="Build the API",            # Required: task description
    depends_on=["plan"],             # Optional: step dependencies
    verification={                   # Optional: completion check
        "type": "output_contains",
        "value": "DONE"
    },
    retries=1,                       # Optional: step-specific retries
    timeout_ms=300000,               # Optional: step-specific timeout
)
```

### `.on_error(strategy, **options)`

Configure error handling:

```python
builder.on_error("retry", max_retries=2, retry_delay_ms=5000)
builder.on_error("fail")      # Stop on first error
builder.on_error("skip")      # Skip failed steps, continue others
```

### `.max_concurrency(n)`

Limit parallel agents:

```python
builder.max_concurrency(3)  # Max 3 agents running simultaneously
```

### `.timeout(ms)`

Set global timeout:

```python
builder.timeout(3600000)  # 1 hour timeout for entire workflow
```

### `.channel(name)`

Set relay channel for agent communication:

```python
builder.channel("feature-123")  # Agents communicate on this channel
```

## Execution Methods

### `.run()`

Execute the workflow and wait for completion:

```python
result = builder.run()

print(result.status)      # 'completed' or 'failed'
print(result.steps)       # Step results
print(result.duration)    # Execution time in ms
```

### `.to_yaml()`

Export workflow as YAML:

```python
yaml_str = builder.to_yaml()
print(yaml_str)
# version: "1.0"
# name: my-workflow
# agents:
#   - name: worker
#     cli: claude
# ...
```

### `.to_config()`

Get the raw configuration dict:

```python
config = builder.to_config()
# Use with WorkflowRunner directly
```

## Running YAML Files

Execute existing YAML workflows:

```python
from agent_relay import run_yaml

result = run_yaml("workflow.yaml")
print(result.status)
```

With variables:

```python
result = run_yaml("workflow.yaml", vars={"task": "Build the feature"})
```

## WorkflowRunner

For more control, use `WorkflowRunner` directly:

```python
from agent_relay import WorkflowRunner

runner = WorkflowRunner(
    cwd="/path/to/project",
    relay_port=3000,
)

# Event callback
def on_event(event):
    if event["type"] == "step:started":
        print(f"Starting: {event['step_name']}")
    elif event["type"] == "step:completed":
        print(f"Completed: {event['step_name']}")
    elif event["type"] == "step:failed":
        print(f"Failed: {event['step_name']}: {event['error']}")

runner.on_event(on_event)

# Parse and execute
config = runner.parse_yaml_file("workflow.yaml")
run = runner.execute(config, "default", vars={"task": "Build the feature"})

# Control execution
runner.pause()
runner.unpause()
runner.abort()

# Resume a failed run
resumed = runner.resume(run.id)
```

## Template Variables

Reference previous step outputs in task descriptions:

```python
(
    builder
    .step("plan", agent="planner", task="Create a plan for: {{task}}")
    .step("implement",
        agent="developer",
        task="Implement based on: {{steps.plan.output}}",  # Reference plan output
        depends_on=["plan"]
    )
)
```

## Complete Example: Code Review Pipeline

```python
from agent_relay import workflow, Models, SwarmPatterns

def review_code(pr_number: int):
    return (
        workflow("code-review")
        .pattern(SwarmPatterns.FAN_OUT)

        .agent("security",
            cli="claude",
            model=Models.Claude.OPUS,
            role="Security reviewer"
        )
        .agent("performance",
            cli="claude",
            model=Models.Claude.SONNET,
            role="Performance reviewer"
        )
        .agent("style",
            cli="codex",
            model=Models.Codex.O3,
            role="Style and best practices reviewer"
        )
        .agent("lead",
            cli="claude",
            model=Models.Claude.OPUS,
            role="Lead reviewer who synthesizes feedback"
        )

        # Parallel reviews
        .step("security_review",
            agent="security",
            task=f"Review PR #{pr_number} for security issues"
        )
        .step("perf_review",
            agent="performance",
            task=f"Review PR #{pr_number} for performance issues"
        )
        .step("style_review",
            agent="style",
            task=f"Review PR #{pr_number} for code style and best practices"
        )

        # Synthesis
        .step("synthesize",
            agent="lead",
            task="""Synthesize reviews and provide final recommendation:
                Security: {{steps.security_review.output}}
                Performance: {{steps.perf_review.output}}
                Style: {{steps.style_review.output}}""",
            depends_on=["security_review", "perf_review", "style_review"]
        )

        .run()
    )


# Usage
result = review_code(123)
print(result.status)
```

## Async Support

For async/await usage:

```python
import asyncio
from agent_relay import workflow, Models

async def main():
    result = await (
        workflow("async-feature")
        .pattern("dag")
        .agent("worker", cli="claude", model=Models.Claude.SONNET)
        .step("work", agent="worker", task="Do the work")
        .run_async()
    )
    print(result.status)

asyncio.run(main())
```

## Next Steps

<CardGroup cols={2}>
  <Card title="TypeScript SDK" icon="js" href="/workflows/typescript-sdk">
    Same fluent API in TypeScript.
  </Card>
  <Card title="Cloud Execution" icon="cloud" href="/workflows/cloud-execution">
    Run workflows 24/7 in the cloud.
  </Card>
</CardGroup>
