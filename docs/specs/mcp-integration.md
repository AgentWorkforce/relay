# MCP Integration Specification

## Executive Summary

This spec defines how Agent Relay integrates with the **Model Context Protocol (MCP)** to provide:

1. **Relay as MCP Server** - Expose relay messaging capabilities as MCP tools, allowing any MCP-compatible client (Claude Desktop, Cursor, custom agents) to send/receive messages through the relay network
2. **Relay as MCP Client** - Enable relay-wrapped agents to consume external MCP tools (databases, file systems, APIs) without terminal I/O
3. **Hybrid Transport** - Keep Unix sockets for local speed (<5ms), add MCP-over-HTTP for remote agents (~50-200ms)
4. **Agent Capability Exchange** - Agents advertise their capabilities as MCP tools that other agents can discover and call

This positions Agent Relay as a **universal coordination layer** that bridges MCP-native and terminal-based agents.

---

## Background

### What is MCP?

The **Model Context Protocol (MCP)** is an open standard created by Anthropic for connecting AI models to external data sources and tools. It provides:

- **Tools**: Functions that models can call (read file, query database, send message)
- **Resources**: Data that models can read (file contents, database records, agent state)
- **Prompts**: Pre-defined prompt templates for common workflows
- **Transports**: Communication channels (stdio, HTTP+SSE, WebSocket)

### Why MCP + Agent Relay?

| Current State | With MCP Integration |
|---------------|---------------------|
| Agents communicate via `->relay:` pattern parsing | Agents can also use structured MCP tool calls |
| Only terminal-based agents supported | Any MCP client can join the relay network |
| No standard for agent capabilities | Agents expose capabilities as MCP tools |
| Remote messaging requires custom protocol | MCP-over-HTTP provides standard remote transport |

### Competitive Context

From our analysis of `mcp_agent_mail`:

| Aspect | mcp_agent_mail | agent-relay | agent-relay + MCP |
|--------|----------------|-------------|-------------------|
| Protocol | MCP-only | Pattern-only | Hybrid (both) |
| Latency | ~50-200ms | <5ms | <5ms local, ~50-200ms remote |
| Agent Integration | Requires MCP SDK | Zero-config | Both options |
| Remote Agents | Native | Not supported | MCP transport |

---

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           Agent Relay Daemon                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                         MCP Server Layer (NEW)                         â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚ â”‚
â”‚  â”‚  â”‚    Tools     â”‚  â”‚  Resources   â”‚  â”‚   Prompts    â”‚                 â”‚ â”‚
â”‚  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚                 â”‚ â”‚
â”‚  â”‚  â”‚ send_message â”‚  â”‚ agents://    â”‚  â”‚ coordinate   â”‚                 â”‚ â”‚
â”‚  â”‚  â”‚ broadcast    â”‚  â”‚ messages://  â”‚  â”‚ handoff      â”‚                 â”‚ â”‚
â”‚  â”‚  â”‚ list_agents  â”‚  â”‚ channels://  â”‚  â”‚ status_reportâ”‚                 â”‚ â”‚
â”‚  â”‚  â”‚ join_channel â”‚  â”‚              â”‚  â”‚              â”‚                 â”‚ â”‚
â”‚  â”‚  â”‚ spawn_agent  â”‚  â”‚              â”‚  â”‚              â”‚                 â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                          â”‚                                                   â”‚
â”‚                          â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                      Transport Adapters                                 â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚ â”‚
â”‚  â”‚  â”‚    stdio     â”‚  â”‚  HTTP+SSE    â”‚  â”‚  WebSocket   â”‚                 â”‚ â”‚
â”‚  â”‚  â”‚  (local)     â”‚  â”‚  (remote)    â”‚  â”‚  (dashboard) â”‚                 â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                          â”‚                                                   â”‚
â”‚                          â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    Existing Relay Core                                  â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚ â”‚
â”‚  â”‚  â”‚    Router    â”‚  â”‚   Storage    â”‚  â”‚  Connection  â”‚                 â”‚ â”‚
â”‚  â”‚  â”‚              â”‚  â”‚   (SQLite)   â”‚  â”‚    Manager   â”‚                 â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                              â”‚                              â”‚
          â–¼                              â–¼                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PTY-Wrapped     â”‚          â”‚   MCP Client     â”‚          â”‚   Remote MCP     â”‚
â”‚  Agents          â”‚          â”‚   (Claude Desktopâ”‚          â”‚   Agents         â”‚
â”‚  (existing)      â”‚          â”‚    Cursor, etc.) â”‚          â”‚   (HTTP+SSE)     â”‚
â”‚                  â”‚          â”‚                  â”‚          â”‚                  â”‚
â”‚  ->relay:Bob ... â”‚          â”‚  tool_call:      â”‚          â”‚  tool_call:      â”‚
â”‚                  â”‚          â”‚  send_message    â”‚          â”‚  send_message    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## User Flows

### Flow 1: MCP Client Sends Message via Relay

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MCP CLIENT SENDING MESSAGE                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User in Claude Desktop wants to message a relay agent
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Claude Desktop                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  User: "Send a message to the Backend agent asking about the auth API"     â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  Claude: I'll send that message to Backend.                                â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  [Tool Call: relay_send_message]                                           â”‚ â”‚
â”‚  â”‚  {                                                                          â”‚ â”‚
â”‚  â”‚    "to": "Backend",                                                        â”‚ â”‚
â”‚  â”‚    "body": "What's the status of the auth API implementation?"             â”‚ â”‚
â”‚  â”‚  }                                                                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ MCP tool_call (stdio transport)
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Agent Relay MCP Server                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  handleToolCall("relay_send_message", {to: "Backend", body: "..."})       â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  1. Validate target agent exists                                           â”‚ â”‚
â”‚  â”‚  2. Create SEND envelope                                                   â”‚ â”‚
â”‚  â”‚  3. Route via existing Router                                              â”‚ â”‚
â”‚  â”‚  4. Return success + message ID                                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ Internal routing (existing)
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Backend Agent (PTY-wrapped)                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Relay message from DesktopUser [msg_abc123]:                              â”‚ â”‚
â”‚  â”‚  What's the status of the auth API implementation?                         â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  Backend Agent responds...                                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flow 2: PTY Agent Calls External MCP Tool

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PTY AGENT USING MCP TOOL                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Backend agent needs to query a database via MCP
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Backend Agent (PTY-wrapped, Claude CLI)                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  "I need to check the user count. Let me query the database.               â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  ->mcp:postgres query SELECT COUNT(*) FROM users                           â”‚ â”‚
â”‚  â”‚  "                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ Pattern detected by wrapper
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TmuxWrapper (Extended)                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  parseMcpCommand("->mcp:postgres query SELECT COUNT(*) FROM users")       â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  1. Extract server: "postgres"                                             â”‚ â”‚
â”‚  â”‚  2. Extract tool: "query"                                                  â”‚ â”‚
â”‚  â”‚  3. Extract args: "SELECT COUNT(*) FROM users"                             â”‚ â”‚
â”‚  â”‚  4. Call MCP client                                                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ MCP tool_call
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  External MCP Server (postgres)                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Execute: SELECT COUNT(*) FROM users                                       â”‚ â”‚
â”‚  â”‚  Return: { count: 1542 }                                                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ Result injected into agent
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Backend Agent                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  MCP result from postgres.query:                                           â”‚ â”‚
â”‚  â”‚  { "count": 1542 }                                                         â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  "Great, there are 1,542 users in the database..."                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flow 3: Remote Agent Joins via MCP Transport

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    REMOTE AGENT CONNECTION                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Remote agent on different machine connects to relay
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Remote Machine                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  $ agent-relay connect --remote https://relay.example.com --name RemoteBot â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  Connecting to relay at https://relay.example.com...                       â”‚ â”‚
â”‚  â”‚  âœ“ Connected as "RemoteBot"                                                â”‚ â”‚
â”‚  â”‚  âœ“ Subscribed to messages                                                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ MCP HTTP+SSE connection
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Agent Relay Daemon (with MCP HTTP transport)                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  HTTP Transport Server (port 3889)                                         â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  POST /mcp/messages     â† Incoming tool calls                              â”‚ â”‚
â”‚  â”‚  GET  /mcp/sse          â† Server-sent events (notifications)               â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  Registered: RemoteBot (remote, HTTP transport)                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ Agent visible in dashboard
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dashboard (localhost:3888)                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Connected Agents:                                                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚  â— Backend    (local, PTY)      Active 2m ago                       â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â— Frontend   (local, PTY)      Active 5m ago                       â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â— RemoteBot  (remote, MCP)     Active now      ðŸŒ                  â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flow 4: Agent Capability Discovery

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CAPABILITY DISCOVERY                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Lead agent wants to find an agent that can review code
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Lead Agent                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  "I need someone to review this PR. Let me check agent capabilities.       â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  ->relay:discover capability:code_review                                   â”‚ â”‚
â”‚  â”‚  "                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Relay Daemon                                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Query MCP capability registry:                                            â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  Agents with "code_review" capability:                                     â”‚ â”‚
â”‚  â”‚  - Reviewer (tools: [review_pr, suggest_fixes, check_style])              â”‚ â”‚
â”‚  â”‚  - Senior (tools: [review_pr, architecture_review])                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Lead Agent                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Relay discovery result:                                                   â”‚ â”‚
â”‚  â”‚  Agents with capability "code_review":                                     â”‚ â”‚
â”‚  â”‚  - Reviewer: review_pr, suggest_fixes, check_style                        â”‚ â”‚
â”‚  â”‚  - Senior: review_pr, architecture_review                                 â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  "I'll ask Reviewer to handle this since they have style checking.         â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  ->relay:Reviewer Please review PR #123 focusing on code style            â”‚ â”‚
â”‚  â”‚  "                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flow 5: Cross-Agent Tool Invocation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CROSS-AGENT TOOL CALL                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Frontend agent wants to use Backend's API testing tool
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Frontend Agent                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  "I need to test the new login endpoint. Backend has an API testing tool. â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  ->mcp:Backend.test_api POST /api/auth/login {"user": "test"}             â”‚ â”‚
â”‚  â”‚  "                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ MCP tool call routed to Backend
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Relay Daemon (MCP Router)                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  1. Parse: server="Backend", tool="test_api"                              â”‚ â”‚
â”‚  â”‚  2. Look up Backend's exposed MCP tools                                   â”‚ â”‚
â”‚  â”‚  3. Forward tool call to Backend's MCP interface                          â”‚ â”‚
â”‚  â”‚  4. Return result to Frontend                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Backend Agent (exposes test_api tool)                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  MCP tool request: test_api                                                â”‚ â”‚
â”‚  â”‚  Args: { method: "POST", path: "/api/auth/login", body: {"user": "test"}} â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  Executing API test...                                                     â”‚ â”‚
â”‚  â”‚  Result: { status: 200, body: { token: "jwt_xxx" } }                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ Result returned
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Frontend Agent                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  MCP result from Backend.test_api:                                         â”‚ â”‚
â”‚  â”‚  { status: 200, body: { token: "jwt_xxx" } }                               â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  "Great, the login endpoint is working. Now I'll update the UI..."         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Component Specifications

### 1. MCP Server (Relay as MCP Server)

**File:** `src/mcp/server.ts`

Exposes relay capabilities as MCP tools that any MCP client can call.

```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import type { Router } from '../daemon/router.js';
import type { AgentRegistry } from '../daemon/agent-registry.js';
import type { StorageAdapter } from '../storage/adapter.js';

export interface McpServerConfig {
  /** Name shown to MCP clients */
  name: string;
  /** Version string */
  version: string;
  /** Reference to relay router for message sending */
  router: Router;
  /** Reference to agent registry */
  registry: AgentRegistry;
  /** Reference to storage for message history */
  storage: StorageAdapter;
}

export class RelayMcpServer {
  private server: Server;
  private config: McpServerConfig;

  constructor(config: McpServerConfig) {
    this.config = config;
    this.server = new Server(
      { name: config.name, version: config.version },
      { capabilities: { tools: {}, resources: {}, prompts: {} } }
    );

    this.registerTools();
    this.registerResources();
    this.registerPrompts();
  }

  // ===========================================================================
  // Tools - Actions that MCP clients can perform
  // ===========================================================================

  private registerTools(): void {
    this.server.setRequestHandler('tools/list', async () => ({
      tools: [
        {
          name: 'relay_send_message',
          description: 'Send a message to another agent in the relay network',
          inputSchema: {
            type: 'object',
            properties: {
              to: {
                type: 'string',
                description: 'Target agent name, or "*" for broadcast',
              },
              body: {
                type: 'string',
                description: 'Message content',
              },
              thread: {
                type: 'string',
                description: 'Optional thread ID for grouping related messages',
              },
            },
            required: ['to', 'body'],
          },
        },
        {
          name: 'relay_list_agents',
          description: 'List all agents currently connected to the relay',
          inputSchema: {
            type: 'object',
            properties: {
              includeMetadata: {
                type: 'boolean',
                description: 'Include agent metadata (task, capabilities)',
              },
            },
          },
        },
        {
          name: 'relay_get_messages',
          description: 'Retrieve recent messages from the relay',
          inputSchema: {
            type: 'object',
            properties: {
              agent: {
                type: 'string',
                description: 'Filter by agent name (sender or recipient)',
              },
              thread: {
                type: 'string',
                description: 'Filter by thread ID',
              },
              limit: {
                type: 'number',
                description: 'Maximum messages to return (default: 50)',
              },
              since: {
                type: 'string',
                description: 'ISO timestamp to fetch messages after',
              },
            },
          },
        },
        {
          name: 'relay_join_channel',
          description: 'Join a channel for topic-based messaging',
          inputSchema: {
            type: 'object',
            properties: {
              channel: {
                type: 'string',
                description: 'Channel name (e.g., "#general", "#backend")',
              },
            },
            required: ['channel'],
          },
        },
        {
          name: 'relay_spawn_agent',
          description: 'Spawn a new agent in the relay network',
          inputSchema: {
            type: 'object',
            properties: {
              name: {
                type: 'string',
                description: 'Name for the new agent',
              },
              cli: {
                type: 'string',
                description: 'CLI to use (claude, codex, gemini)',
              },
              task: {
                type: 'string',
                description: 'Initial task for the agent',
              },
            },
            required: ['name', 'cli', 'task'],
          },
        },
        {
          name: 'relay_release_agent',
          description: 'Release (stop) an agent from the relay network',
          inputSchema: {
            type: 'object',
            properties: {
              name: {
                type: 'string',
                description: 'Name of the agent to release',
              },
            },
            required: ['name'],
          },
        },
        {
          name: 'relay_discover_capabilities',
          description: 'Find agents with specific capabilities',
          inputSchema: {
            type: 'object',
            properties: {
              capability: {
                type: 'string',
                description: 'Capability to search for (e.g., "code_review")',
              },
              tool: {
                type: 'string',
                description: 'Specific tool name to search for',
              },
            },
          },
        },
      ],
    }));

    this.server.setRequestHandler('tools/call', async (request) => {
      const { name, arguments: args } = request.params;

      switch (name) {
        case 'relay_send_message':
          return this.handleSendMessage(args);
        case 'relay_list_agents':
          return this.handleListAgents(args);
        case 'relay_get_messages':
          return this.handleGetMessages(args);
        case 'relay_join_channel':
          return this.handleJoinChannel(args);
        case 'relay_spawn_agent':
          return this.handleSpawnAgent(args);
        case 'relay_release_agent':
          return this.handleReleaseAgent(args);
        case 'relay_discover_capabilities':
          return this.handleDiscoverCapabilities(args);
        default:
          throw new Error(`Unknown tool: ${name}`);
      }
    });
  }

  // ===========================================================================
  // Resources - Data that MCP clients can read
  // ===========================================================================

  private registerResources(): void {
    this.server.setRequestHandler('resources/list', async () => ({
      resources: [
        {
          uri: 'relay://agents',
          name: 'Connected Agents',
          description: 'List of all agents currently in the relay network',
          mimeType: 'application/json',
        },
        {
          uri: 'relay://messages',
          name: 'Recent Messages',
          description: 'Recent messages in the relay network',
          mimeType: 'application/json',
        },
        {
          uri: 'relay://channels',
          name: 'Active Channels',
          description: 'List of active channels and their members',
          mimeType: 'application/json',
        },
        {
          uri: 'relay://capabilities',
          name: 'Agent Capabilities',
          description: 'Registry of agent capabilities and tools',
          mimeType: 'application/json',
        },
      ],
    }));

    this.server.setRequestHandler('resources/read', async (request) => {
      const { uri } = request.params;

      switch (uri) {
        case 'relay://agents':
          return this.readAgentsResource();
        case 'relay://messages':
          return this.readMessagesResource();
        case 'relay://channels':
          return this.readChannelsResource();
        case 'relay://capabilities':
          return this.readCapabilitiesResource();
        default:
          // Handle parameterized URIs
          if (uri.startsWith('relay://agents/')) {
            const agentName = uri.replace('relay://agents/', '');
            return this.readAgentResource(agentName);
          }
          throw new Error(`Unknown resource: ${uri}`);
      }
    });
  }

  // ===========================================================================
  // Prompts - Pre-defined prompt templates
  // ===========================================================================

  private registerPrompts(): void {
    this.server.setRequestHandler('prompts/list', async () => ({
      prompts: [
        {
          name: 'coordinate_task',
          description: 'Coordinate a task across multiple agents',
          arguments: [
            {
              name: 'task',
              description: 'The task to coordinate',
              required: true,
            },
            {
              name: 'agents',
              description: 'Comma-separated list of agent names',
              required: true,
            },
          ],
        },
        {
          name: 'handoff_work',
          description: 'Hand off work to another agent with context',
          arguments: [
            {
              name: 'to',
              description: 'Agent to hand off to',
              required: true,
            },
            {
              name: 'context',
              description: 'Context to include in handoff',
              required: true,
            },
          ],
        },
        {
          name: 'status_report',
          description: 'Generate a status report for the team',
          arguments: [
            {
              name: 'channel',
              description: 'Channel to report to (default: #general)',
              required: false,
            },
          ],
        },
      ],
    }));

    this.server.setRequestHandler('prompts/get', async (request) => {
      const { name, arguments: args } = request.params;

      switch (name) {
        case 'coordinate_task':
          return this.getCoordinateTaskPrompt(args);
        case 'handoff_work':
          return this.getHandoffWorkPrompt(args);
        case 'status_report':
          return this.getStatusReportPrompt(args);
        default:
          throw new Error(`Unknown prompt: ${name}`);
      }
    });
  }

  // ===========================================================================
  // Tool Handlers
  // ===========================================================================

  private async handleSendMessage(args: Record<string, unknown>) {
    const { to, body, thread } = args as {
      to: string;
      body: string;
      thread?: string;
    };

    const messageId = await this.config.router.route({
      to,
      body,
      thread,
      from: 'mcp-client', // Will be replaced with authenticated identity
    });

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ success: true, messageId }),
        },
      ],
    };
  }

  private async handleListAgents(args: Record<string, unknown>) {
    const { includeMetadata } = args as { includeMetadata?: boolean };
    const agents = this.config.registry.getAgents();

    const result = agents.map((agent) => ({
      name: agent.name,
      status: agent.status,
      ...(includeMetadata && {
        task: agent.task,
        capabilities: agent.capabilities,
        cli: agent.cli,
        connectedAt: agent.connectedAt,
      }),
    }));

    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],
    };
  }

  private async handleGetMessages(args: Record<string, unknown>) {
    const { agent, thread, limit = 50, since } = args as {
      agent?: string;
      thread?: string;
      limit?: number;
      since?: string;
    };

    const messages = await this.config.storage.getMessages({
      agent,
      thread,
      limit,
      since: since ? new Date(since) : undefined,
    });

    return {
      content: [{ type: 'text', text: JSON.stringify(messages, null, 2) }],
    };
  }

  private async handleJoinChannel(args: Record<string, unknown>) {
    const { channel } = args as { channel: string };
    // Implementation would interact with channel manager
    return {
      content: [
        { type: 'text', text: JSON.stringify({ success: true, channel }) },
      ],
    };
  }

  private async handleSpawnAgent(args: Record<string, unknown>) {
    const { name, cli, task } = args as {
      name: string;
      cli: string;
      task: string;
    };
    // Implementation would interact with spawner
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ success: true, name, status: 'spawning' }),
        },
      ],
    };
  }

  private async handleReleaseAgent(args: Record<string, unknown>) {
    const { name } = args as { name: string };
    // Implementation would interact with spawner
    return {
      content: [
        { type: 'text', text: JSON.stringify({ success: true, name }) },
      ],
    };
  }

  private async handleDiscoverCapabilities(args: Record<string, unknown>) {
    const { capability, tool } = args as {
      capability?: string;
      tool?: string;
    };

    const agents = this.config.registry.getAgents();
    const matches = agents.filter((agent) => {
      if (capability && agent.capabilities?.includes(capability)) return true;
      if (tool && agent.tools?.some((t) => t.name === tool)) return true;
      return false;
    });

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(
            matches.map((a) => ({
              name: a.name,
              capabilities: a.capabilities,
              tools: a.tools?.map((t) => t.name),
            })),
            null,
            2
          ),
        },
      ],
    };
  }

  // ===========================================================================
  // Resource Readers
  // ===========================================================================

  private async readAgentsResource() {
    const agents = this.config.registry.getAgents();
    return {
      contents: [
        {
          uri: 'relay://agents',
          mimeType: 'application/json',
          text: JSON.stringify(agents, null, 2),
        },
      ],
    };
  }

  private async readMessagesResource() {
    const messages = await this.config.storage.getMessages({ limit: 100 });
    return {
      contents: [
        {
          uri: 'relay://messages',
          mimeType: 'application/json',
          text: JSON.stringify(messages, null, 2),
        },
      ],
    };
  }

  private async readChannelsResource() {
    // Implementation would get channels from channel manager
    return {
      contents: [
        {
          uri: 'relay://channels',
          mimeType: 'application/json',
          text: JSON.stringify([], null, 2),
        },
      ],
    };
  }

  private async readCapabilitiesResource() {
    const agents = this.config.registry.getAgents();
    const capabilities = new Map<string, string[]>();

    for (const agent of agents) {
      for (const cap of agent.capabilities ?? []) {
        if (!capabilities.has(cap)) {
          capabilities.set(cap, []);
        }
        capabilities.get(cap)!.push(agent.name);
      }
    }

    return {
      contents: [
        {
          uri: 'relay://capabilities',
          mimeType: 'application/json',
          text: JSON.stringify(Object.fromEntries(capabilities), null, 2),
        },
      ],
    };
  }

  private async readAgentResource(agentName: string) {
    const agent = this.config.registry.getAgent(agentName);
    if (!agent) {
      throw new Error(`Agent not found: ${agentName}`);
    }
    return {
      contents: [
        {
          uri: `relay://agents/${agentName}`,
          mimeType: 'application/json',
          text: JSON.stringify(agent, null, 2),
        },
      ],
    };
  }

  // ===========================================================================
  // Prompt Generators
  // ===========================================================================

  private getCoordinateTaskPrompt(args: Record<string, string>) {
    const { task, agents } = args;
    return {
      messages: [
        {
          role: 'user',
          content: {
            type: 'text',
            text: `You are coordinating the following task across these agents: ${agents}

Task: ${task}

Steps:
1. Use relay_list_agents to check which agents are available
2. Use relay_send_message to assign subtasks to each agent
3. Monitor progress by reading relay://messages
4. Coordinate handoffs between agents as needed
5. Report completion to #general channel`,
          },
        },
      ],
    };
  }

  private getHandoffWorkPrompt(args: Record<string, string>) {
    const { to, context } = args;
    return {
      messages: [
        {
          role: 'user',
          content: {
            type: 'text',
            text: `Hand off work to ${to} with the following context:

${context}

Use relay_send_message to send a detailed handoff message including:
1. What has been completed
2. What remains to be done
3. Any blockers or considerations
4. Relevant file paths or references`,
          },
        },
      ],
    };
  }

  private getStatusReportPrompt(args: Record<string, string>) {
    const channel = args.channel ?? '#general';
    return {
      messages: [
        {
          role: 'user',
          content: {
            type: 'text',
            text: `Generate a status report for the team and send to ${channel}:

1. Use relay_list_agents with includeMetadata=true
2. Use relay_get_messages with limit=20
3. Summarize:
   - Active agents and their current tasks
   - Recent activity and progress
   - Any blockers or issues
4. Use relay_send_message to post to ${channel}`,
          },
        },
      ],
    };
  }

  // ===========================================================================
  // Server Lifecycle
  // ===========================================================================

  async start(transport: 'stdio' | 'http' = 'stdio'): Promise<void> {
    if (transport === 'stdio') {
      const stdioTransport = new StdioServerTransport();
      await this.server.connect(stdioTransport);
    } else {
      // HTTP transport handled separately
      throw new Error('HTTP transport requires HttpMcpTransport');
    }
  }

  async stop(): Promise<void> {
    await this.server.close();
  }
}
```

### 2. MCP HTTP Transport Server

**File:** `src/mcp/http-transport.ts`

HTTP+SSE transport for remote MCP clients.

```typescript
import express, { type Express, type Request, type Response } from 'express';
import type { Server as HttpServer } from 'node:http';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import type { RelayMcpServer } from './server.js';

export interface HttpMcpTransportConfig {
  /** Port to listen on (default: 3889) */
  port: number;
  /** Host to bind to (default: localhost) */
  host: string;
  /** Enable CORS for browser clients */
  cors: boolean;
  /** API key for authentication (optional) */
  apiKey?: string;
}

export class HttpMcpTransport {
  private app: Express;
  private httpServer?: HttpServer;
  private mcpServer: RelayMcpServer;
  private config: HttpMcpTransportConfig;
  private clients: Map<string, SSEServerTransport> = new Map();

  constructor(mcpServer: RelayMcpServer, config: HttpMcpTransportConfig) {
    this.mcpServer = mcpServer;
    this.config = config;
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupMiddleware(): void {
    this.app.use(express.json());

    if (this.config.cors) {
      this.app.use((_req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
        res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
        next();
      });
    }

    // Optional API key authentication
    if (this.config.apiKey) {
      this.app.use((req, res, next) => {
        const auth = req.headers.authorization;
        if (auth !== `Bearer ${this.config.apiKey}`) {
          return res.status(401).json({ error: 'Unauthorized' });
        }
        next();
      });
    }
  }

  private setupRoutes(): void {
    // SSE endpoint for server-to-client messages
    this.app.get('/mcp/sse', (req: Request, res: Response) => {
      const clientId = req.query.clientId as string ?? crypto.randomUUID();

      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');

      const transport = new SSEServerTransport('/mcp/messages', res);
      this.clients.set(clientId, transport);

      req.on('close', () => {
        this.clients.delete(clientId);
      });

      // Send initial connection event
      res.write(`data: ${JSON.stringify({ type: 'connected', clientId })}\n\n`);
    });

    // POST endpoint for client-to-server messages
    this.app.post('/mcp/messages', async (req: Request, res: Response) => {
      const clientId = req.query.clientId as string;
      const transport = this.clients.get(clientId);

      if (!transport) {
        return res.status(400).json({ error: 'No SSE connection for client' });
      }

      try {
        // Process MCP message through transport
        await transport.handlePostMessage(req, res);
      } catch (error: unknown) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        res.status(500).json({ error: message });
      }
    });

    // Health check
    this.app.get('/mcp/health', (_req: Request, res: Response) => {
      res.json({
        status: 'ok',
        clients: this.clients.size,
        uptime: process.uptime(),
      });
    });
  }

  async start(): Promise<void> {
    return new Promise((resolve) => {
      this.httpServer = this.app.listen(this.config.port, this.config.host, () => {
        console.log(
          `[mcp-http] MCP HTTP transport listening on ${this.config.host}:${this.config.port}`
        );
        resolve();
      });
    });
  }

  async stop(): Promise<void> {
    // Close all client connections
    for (const [clientId, transport] of this.clients) {
      try {
        await transport.close();
      } catch {
        // Ignore close errors
      }
      this.clients.delete(clientId);
    }

    // Close HTTP server
    return new Promise((resolve) => {
      if (this.httpServer) {
        this.httpServer.close(() => resolve());
      } else {
        resolve();
      }
    });
  }
}
```

### 3. MCP Client (Relay as MCP Client)

**File:** `src/mcp/client.ts`

Allows relay-wrapped agents to call external MCP tools.

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { spawn, type ChildProcess } from 'node:child_process';

export interface McpServerConnection {
  /** Server name (used for ->mcp:name patterns) */
  name: string;
  /** Command to start the MCP server */
  command: string;
  /** Command arguments */
  args?: string[];
  /** Environment variables */
  env?: Record<string, string>;
  /** Working directory */
  cwd?: string;
}

export interface McpClientConfig {
  /** MCP servers to connect to */
  servers: McpServerConnection[];
}

export interface ToolCallRequest {
  server: string;
  tool: string;
  arguments: Record<string, unknown>;
}

export class RelayMcpClient {
  private clients: Map<string, Client> = new Map();
  private processes: Map<string, ChildProcess> = new Map();
  private config: McpClientConfig;
  private toolCache: Map<string, unknown[]> = new Map();

  constructor(config: McpClientConfig) {
    this.config = config;
  }

  /**
   * Connect to all configured MCP servers
   */
  async connect(): Promise<void> {
    for (const server of this.config.servers) {
      await this.connectServer(server);
    }
  }

  /**
   * Connect to a single MCP server
   */
  private async connectServer(server: McpServerConnection): Promise<void> {
    const process = spawn(server.command, server.args ?? [], {
      cwd: server.cwd,
      env: { ...process.env, ...server.env },
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    this.processes.set(server.name, process);

    const transport = new StdioClientTransport({
      command: server.command,
      args: server.args,
      env: server.env,
    });

    const client = new Client(
      { name: `relay-mcp-client-${server.name}`, version: '1.0.0' },
      { capabilities: {} }
    );

    await client.connect(transport);
    this.clients.set(server.name, client);

    // Cache available tools
    const tools = await client.listTools();
    this.toolCache.set(server.name, tools.tools);

    console.log(
      `[mcp-client] Connected to ${server.name} with ${tools.tools.length} tools`
    );
  }

  /**
   * Disconnect from all MCP servers
   */
  async disconnect(): Promise<void> {
    for (const [name, client] of this.clients) {
      try {
        await client.close();
      } catch {
        // Ignore close errors
      }
      this.clients.delete(name);
    }

    for (const [name, proc] of this.processes) {
      proc.kill();
      this.processes.delete(name);
    }
  }

  /**
   * Call a tool on an MCP server
   */
  async callTool(request: ToolCallRequest): Promise<unknown> {
    const client = this.clients.get(request.server);
    if (!client) {
      throw new Error(`MCP server not connected: ${request.server}`);
    }

    const result = await client.callTool({
      name: request.tool,
      arguments: request.arguments,
    });

    return result;
  }

  /**
   * List available tools from all servers or a specific server
   */
  listTools(serverName?: string): Map<string, unknown[]> {
    if (serverName) {
      const tools = this.toolCache.get(serverName);
      if (!tools) {
        throw new Error(`MCP server not connected: ${serverName}`);
      }
      return new Map([[serverName, tools]]);
    }
    return new Map(this.toolCache);
  }

  /**
   * Read a resource from an MCP server
   */
  async readResource(server: string, uri: string): Promise<unknown> {
    const client = this.clients.get(server);
    if (!client) {
      throw new Error(`MCP server not connected: ${server}`);
    }

    const result = await client.readResource({ uri });
    return result;
  }

  /**
   * Check if a server is connected
   */
  isConnected(serverName: string): boolean {
    return this.clients.has(serverName);
  }

  /**
   * Get all connected server names
   */
  getConnectedServers(): string[] {
    return Array.from(this.clients.keys());
  }
}
```

### 4. MCP Pattern Parser Extension

**File:** `src/wrapper/mcp-parser.ts`

Extends the output parser to detect `->mcp:` patterns.

```typescript
export interface McpCommand {
  server: string;
  tool: string;
  arguments: string;
  raw: string;
}

/**
 * Parse MCP command patterns from agent output
 *
 * Supported formats:
 *   ->mcp:server tool arg1 arg2
 *   ->mcp:server.tool { "json": "args" }
 *   ->mcp:Server.tool_name query string here
 */
export function parseMcpCommand(line: string): McpCommand | null {
  // Pattern: ->mcp:server tool args
  const simpleMatch = line.match(/^->mcp:(\w+)\s+(\w+)\s+(.+)$/);
  if (simpleMatch) {
    return {
      server: simpleMatch[1],
      tool: simpleMatch[2],
      arguments: simpleMatch[3],
      raw: line,
    };
  }

  // Pattern: ->mcp:server.tool args
  const dotMatch = line.match(/^->mcp:(\w+)\.(\w+)\s+(.+)$/);
  if (dotMatch) {
    return {
      server: dotMatch[1],
      tool: dotMatch[2],
      arguments: dotMatch[3],
      raw: line,
    };
  }

  // Pattern: ->mcp:server.tool (no args)
  const noArgsMatch = line.match(/^->mcp:(\w+)\.(\w+)$/);
  if (noArgsMatch) {
    return {
      server: noArgsMatch[1],
      tool: noArgsMatch[2],
      arguments: '',
      raw: line,
    };
  }

  return null;
}

/**
 * Parse MCP command arguments into a structured object
 */
export function parseArguments(
  argsString: string
): Record<string, unknown> | string {
  // Try JSON first
  if (argsString.trim().startsWith('{')) {
    try {
      return JSON.parse(argsString);
    } catch {
      // Fall through to string
    }
  }

  // Return as raw string if not JSON
  return argsString;
}

/**
 * Format MCP result for injection into agent terminal
 */
export function formatMcpResult(
  server: string,
  tool: string,
  result: unknown
): string {
  const resultStr =
    typeof result === 'string' ? result : JSON.stringify(result, null, 2);

  return `MCP result from ${server}.${tool}:\n${resultStr}`;
}

/**
 * Format MCP error for injection into agent terminal
 */
export function formatMcpError(
  server: string,
  tool: string,
  error: Error
): string {
  return `MCP error from ${server}.${tool}: ${error.message}`;
}
```

### 5. Agent Capability Registry

**File:** `src/mcp/capability-registry.ts`

Tracks what capabilities/tools each agent exposes.

```typescript
export interface AgentCapability {
  /** Capability category (e.g., "code_review", "testing", "deployment") */
  category: string;
  /** Human-readable description */
  description: string;
}

export interface AgentTool {
  /** Tool name (used in MCP calls) */
  name: string;
  /** Human-readable description */
  description: string;
  /** JSON Schema for tool arguments */
  inputSchema: Record<string, unknown>;
}

export interface AgentCapabilities {
  /** Agent name */
  agentName: string;
  /** List of capability categories */
  capabilities: AgentCapability[];
  /** List of tools this agent exposes */
  tools: AgentTool[];
  /** When capabilities were last updated */
  updatedAt: Date;
}

export class CapabilityRegistry {
  private registry: Map<string, AgentCapabilities> = new Map();

  /**
   * Register an agent's capabilities
   */
  register(capabilities: AgentCapabilities): void {
    this.registry.set(capabilities.agentName, {
      ...capabilities,
      updatedAt: new Date(),
    });
  }

  /**
   * Unregister an agent
   */
  unregister(agentName: string): void {
    this.registry.delete(agentName);
  }

  /**
   * Find agents with a specific capability
   */
  findByCapability(category: string): AgentCapabilities[] {
    const results: AgentCapabilities[] = [];
    for (const caps of this.registry.values()) {
      if (caps.capabilities.some((c) => c.category === category)) {
        results.push(caps);
      }
    }
    return results;
  }

  /**
   * Find agents with a specific tool
   */
  findByTool(toolName: string): AgentCapabilities[] {
    const results: AgentCapabilities[] = [];
    for (const caps of this.registry.values()) {
      if (caps.tools.some((t) => t.name === toolName)) {
        results.push(caps);
      }
    }
    return results;
  }

  /**
   * Get all capabilities for an agent
   */
  get(agentName: string): AgentCapabilities | undefined {
    return this.registry.get(agentName);
  }

  /**
   * Get all registered capabilities
   */
  getAll(): AgentCapabilities[] {
    return Array.from(this.registry.values());
  }

  /**
   * Get a summary of all capabilities
   */
  getSummary(): Record<string, string[]> {
    const summary: Record<string, string[]> = {};
    for (const caps of this.registry.values()) {
      for (const cap of caps.capabilities) {
        if (!summary[cap.category]) {
          summary[cap.category] = [];
        }
        summary[cap.category].push(caps.agentName);
      }
    }
    return summary;
  }
}
```

### 6. Extended Wrapper with MCP Support

**File:** `src/wrapper/mcp-wrapper-extension.ts`

Extension mixin for TmuxWrapper to handle MCP patterns.

```typescript
import type { RelayMcpClient, ToolCallRequest } from '../mcp/client.js';
import {
  parseMcpCommand,
  parseArguments,
  formatMcpResult,
  formatMcpError,
} from './mcp-parser.js';

export interface McpWrapperConfig {
  /** MCP client instance for calling external tools */
  mcpClient?: RelayMcpClient;
  /** Whether to enable MCP pattern detection */
  enableMcp: boolean;
}

/**
 * Mixin to add MCP support to any wrapper
 */
export function withMcpSupport<
  T extends new (...args: unknown[]) => { performInjection: (content: string) => Promise<void> }
>(Base: T, config: McpWrapperConfig) {
  return class extends Base {
    private mcpClient?: RelayMcpClient = config.mcpClient;
    private mcpEnabled: boolean = config.enableMcp;

    /**
     * Process a line of output for MCP commands
     */
    async processMcpCommand(line: string): Promise<boolean> {
      if (!this.mcpEnabled || !this.mcpClient) {
        return false;
      }

      const cmd = parseMcpCommand(line);
      if (!cmd) {
        return false;
      }

      try {
        const args = parseArguments(cmd.arguments);
        const request: ToolCallRequest = {
          server: cmd.server,
          tool: cmd.tool,
          arguments: typeof args === 'string' ? { query: args } : args,
        };

        const result = await this.mcpClient.callTool(request);
        const formatted = formatMcpResult(cmd.server, cmd.tool, result);

        // Inject result back into agent
        await this.performInjection(formatted);
        return true;
      } catch (error) {
        const formatted = formatMcpError(
          cmd.server,
          cmd.tool,
          error instanceof Error ? error : new Error(String(error))
        );
        await this.performInjection(formatted);
        return true;
      }
    }
  };
}
```

---

## Integration with Existing Components

### 1. Daemon Integration

**File:** `src/daemon/server.ts` (modifications)

```typescript
import { RelayMcpServer } from '../mcp/server.js';
import { HttpMcpTransport } from '../mcp/http-transport.js';

export interface DaemonConfig {
  // ... existing config ...

  /** Enable MCP server */
  mcp?: {
    enabled: boolean;
    /** stdio transport for local MCP clients */
    stdio?: boolean;
    /** HTTP transport for remote MCP clients */
    http?: {
      enabled: boolean;
      port: number;
      host: string;
      apiKey?: string;
    };
  };
}

export class RelayDaemon {
  private mcpServer?: RelayMcpServer;
  private mcpHttpTransport?: HttpMcpTransport;

  async start(): Promise<void> {
    // ... existing startup ...

    // Start MCP server if enabled
    if (this.config.mcp?.enabled) {
      this.mcpServer = new RelayMcpServer({
        name: 'agent-relay',
        version: '1.0.0',
        router: this.router,
        registry: this.agentRegistry,
        storage: this.storage,
      });

      if (this.config.mcp.stdio) {
        await this.mcpServer.start('stdio');
        console.log('[daemon] MCP stdio transport started');
      }

      if (this.config.mcp.http?.enabled) {
        this.mcpHttpTransport = new HttpMcpTransport(this.mcpServer, {
          port: this.config.mcp.http.port,
          host: this.config.mcp.http.host,
          cors: true,
          apiKey: this.config.mcp.http.apiKey,
        });
        await this.mcpHttpTransport.start();
        console.log(
          `[daemon] MCP HTTP transport started on ${this.config.mcp.http.host}:${this.config.mcp.http.port}`
        );
      }
    }
  }

  async stop(): Promise<void> {
    // Stop MCP transports
    if (this.mcpHttpTransport) {
      await this.mcpHttpTransport.stop();
    }
    if (this.mcpServer) {
      await this.mcpServer.stop();
    }

    // ... existing shutdown ...
  }
}
```

### 2. CLI Integration

**File:** `src/cli/index.ts` (additions)

```typescript
program
  .option('--mcp', 'Enable MCP server (stdio transport)')
  .option('--mcp-http [port]', 'Enable MCP HTTP transport on specified port')
  .option('--mcp-api-key <key>', 'API key for MCP HTTP authentication')
  .option(
    '--mcp-servers <config>',
    'Path to MCP servers config file for client mode'
  );

// In daemon startup:
const mcpConfig = {
  enabled: options.mcp || options.mcpHttp,
  stdio: options.mcp,
  http: options.mcpHttp
    ? {
        enabled: true,
        port:
          typeof options.mcpHttp === 'string'
            ? parseInt(options.mcpHttp, 10)
            : 3889,
        host: 'localhost',
        apiKey: options.mcpApiKey,
      }
    : undefined,
};
```

### 3. Dashboard API Integration

**File:** `src/dashboard-server/routes/mcp.ts`

```typescript
import { Router } from 'express';
import type { CapabilityRegistry } from '../../mcp/capability-registry.js';
import type { RelayMcpClient } from '../../mcp/client.js';

export function createMcpRoutes(
  capabilityRegistry: CapabilityRegistry,
  mcpClient?: RelayMcpClient
): Router {
  const router = Router();

  /**
   * GET /api/mcp/capabilities
   * List all registered agent capabilities
   */
  router.get('/capabilities', (_req, res) => {
    const capabilities = capabilityRegistry.getAll();
    res.json({ capabilities });
  });

  /**
   * GET /api/mcp/capabilities/summary
   * Get capability summary (category -> agent names)
   */
  router.get('/capabilities/summary', (_req, res) => {
    const summary = capabilityRegistry.getSummary();
    res.json({ summary });
  });

  /**
   * GET /api/mcp/servers
   * List connected MCP servers (client mode)
   */
  router.get('/servers', (_req, res) => {
    if (!mcpClient) {
      return res.json({ servers: [] });
    }
    const servers = mcpClient.getConnectedServers();
    const tools = mcpClient.listTools();

    res.json({
      servers: servers.map((name) => ({
        name,
        tools: tools.get(name),
      })),
    });
  });

  /**
   * POST /api/mcp/call
   * Call an MCP tool (proxy for dashboard)
   */
  router.post('/call', async (req, res) => {
    if (!mcpClient) {
      return res.status(400).json({ error: 'MCP client not enabled' });
    }

    const { server, tool, arguments: args } = req.body;

    try {
      const result = await mcpClient.callTool({ server, tool, arguments: args });
      res.json({ success: true, result });
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      res.status(500).json({ success: false, error: message });
    }
  });

  return router;
}
```

---

## Configuration

### Environment Variables

```bash
# Enable MCP server (stdio transport for local clients)
RELAY_MCP_ENABLED=true

# Enable MCP HTTP transport for remote clients
RELAY_MCP_HTTP_ENABLED=true
RELAY_MCP_HTTP_PORT=3889
RELAY_MCP_HTTP_HOST=0.0.0.0

# API key for MCP HTTP authentication (optional)
RELAY_MCP_API_KEY=your-secret-key

# Path to MCP servers config for client mode
RELAY_MCP_SERVERS_CONFIG=./mcp-servers.json
```

### MCP Servers Config File

**File:** `mcp-servers.json`

```json
{
  "servers": [
    {
      "name": "postgres",
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres"],
      "env": {
        "POSTGRES_CONNECTION_STRING": "postgresql://user:pass@localhost/db"
      }
    },
    {
      "name": "filesystem",
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
    },
    {
      "name": "github",
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "${GITHUB_TOKEN}"
      }
    }
  ]
}
```

### Claude Desktop Configuration

To use Agent Relay as an MCP server in Claude Desktop:

**File:** `~/Library/Application Support/Claude/claude_desktop_config.json`

```json
{
  "mcpServers": {
    "agent-relay": {
      "command": "agent-relay",
      "args": ["mcp-server"],
      "env": {
        "RELAY_PROJECT_ROOT": "/path/to/project"
      }
    }
  }
}
```

---

## Protocol Extensions

### Extended HELLO Payload

```typescript
export interface HelloPayload {
  // ... existing fields ...

  /** Agent capabilities for MCP discovery */
  capabilities?: string[];

  /** Tools this agent exposes via MCP */
  tools?: Array<{
    name: string;
    description: string;
    inputSchema: Record<string, unknown>;
  }>;

  /** Whether agent supports receiving MCP tool calls */
  mcpEnabled?: boolean;
}
```

### New Message Types

```typescript
// MCP tool call between agents
export interface McpToolCallPayload {
  kind: 'mcp_tool_call';
  server: string; // Target agent name
  tool: string;
  arguments: Record<string, unknown>;
  callId: string; // For matching response
}

// MCP tool result
export interface McpToolResultPayload {
  kind: 'mcp_tool_result';
  callId: string;
  result?: unknown;
  error?: string;
}

// Capability announcement
export interface CapabilityAnnouncementPayload {
  kind: 'capability_announcement';
  capabilities: string[];
  tools: Array<{
    name: string;
    description: string;
    inputSchema: Record<string, unknown>;
  }>;
}
```

---

## Implementation Phases

### Phase 1: MCP Server Core
- [ ] Create `RelayMcpServer` with basic tools (send_message, list_agents)
- [ ] Add resources (relay://agents, relay://messages)
- [ ] Implement stdio transport
- [ ] Add CLI flag `--mcp`
- [ ] Test with Claude Desktop

### Phase 2: HTTP Transport
- [ ] Create `HttpMcpTransport` with SSE
- [ ] Add authentication (API key)
- [ ] Add CLI flag `--mcp-http`
- [ ] Test remote client connection

### Phase 3: MCP Client
- [ ] Create `RelayMcpClient` for connecting to external MCP servers
- [ ] Add `->mcp:` pattern parsing to wrapper
- [ ] Implement tool call and result injection
- [ ] Add MCP servers config file support

### Phase 4: Capability Registry
- [ ] Create `CapabilityRegistry`
- [ ] Extend HELLO payload with capabilities
- [ ] Add `relay_discover_capabilities` tool
- [ ] Add dashboard UI for capabilities

### Phase 5: Cross-Agent MCP
- [ ] Enable agents to expose tools via MCP
- [ ] Implement cross-agent tool routing
- [ ] Add `->mcp:AgentName.tool` pattern
- [ ] Test agent-to-agent tool calls

### Phase 6: Polish & Documentation
- [ ] Add prompts (coordinate_task, handoff_work)
- [ ] Performance optimization
- [ ] Comprehensive documentation
- [ ] Example configurations

---

## Testing Strategy

### Unit Tests

- MCP Server tool handlers
- MCP Client connection management
- Pattern parsing (`->mcp:` format)
- Capability registry queries

### Integration Tests

- Full MCP tool call cycle (client â†’ server â†’ router â†’ agent)
- HTTP transport with authentication
- Cross-agent MCP tool calls
- Mixed PTY + MCP agent scenarios

### E2E Tests

- Claude Desktop integration
- Remote agent via HTTP transport
- Multi-agent coordination via MCP prompts

---

## Security Considerations

### Authentication

| Transport | Authentication | Default |
|-----------|----------------|---------|
| stdio | Unix user permissions | Enabled |
| HTTP | API key (Bearer token) | Optional |
| WebSocket | Session token | Required |

### Authorization

- MCP tools respect existing relay permissions
- Agent capabilities are self-declared (trust model)
- Cross-agent tool calls require both agents to be connected

### Network Security

- HTTP transport uses TLS in production
- API keys should be rotated regularly
- Rate limiting on HTTP transport recommended

---

## Performance Considerations

### Latency Targets

| Path | Target | Notes |
|------|--------|-------|
| Local MCP (stdio) | <10ms | Same as Unix socket |
| HTTP MCP (local) | <50ms | Localhost HTTP |
| HTTP MCP (remote) | <200ms | Network dependent |
| Cross-agent tool | <100ms | Routing + tool execution |

### Optimizations

1. **Connection pooling** - Reuse MCP client connections
2. **Tool caching** - Cache tool lists from MCP servers
3. **Batch operations** - Support multiple tool calls in single request
4. **Lazy loading** - Only connect to MCP servers when needed

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| MCP SDK instability | Breaking changes | Pin SDK version, add version checks |
| HTTP transport overhead | Increased latency | Keep stdio for local, HTTP for remote only |
| Tool call failures | Agent confusion | Clear error formatting, retry logic |
| Capability sprawl | Discovery noise | Capability categories, search filters |
| Security exposure | Unauthorized access | API key auth, IP allowlisting |

---

## Success Metrics

1. **Adoption**: Number of MCP clients connecting to relay
2. **Latency**: P99 latency for MCP tool calls <200ms
3. **Reliability**: 99.9% tool call success rate
4. **Discovery**: Average time to find capable agent <500ms
5. **Integration**: Successfully integrated with Claude Desktop, Cursor

---

## Dependencies

```json
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21"
  }
}
```

---

## References

- [MCP Specification](https://spec.modelcontextprotocol.io/)
- [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [MCP Servers Repository](https://github.com/modelcontextprotocol/servers)
- [Claude Desktop MCP Setup](https://docs.anthropic.com/claude/docs/mcp)
- [Agent Relay Architecture](../architecture.md)
- [mcp_agent_mail Competitive Analysis](../competitive/MCP_AGENT_MAIL.md)

---

## Appendix: Pattern Reference

### Relay Patterns (Existing)

```
->relay:AgentName message          # Direct message
->relay:* message                  # Broadcast
->relay:#channel message           # Channel message
->relay:spawn Name cli task        # Spawn agent
->relay:release Name               # Release agent
```

### MCP Patterns (New)

```
->mcp:server tool args             # Call external MCP tool
->mcp:server.tool args             # Alternative dot notation
->mcp:server.tool {"json": "args"} # JSON arguments
->mcp:AgentName.tool args          # Call another agent's tool
->relay:discover capability:name   # Find agents by capability
```

### Combined Example

```
# Agent using both relay messaging and MCP tools

->relay:Backend Auth API is ready for integration
->mcp:postgres query SELECT COUNT(*) FROM users
->mcp:Backend.test_api POST /api/auth/login {"user": "test"}
->relay:discover capability:testing
->relay:#general Build complete, ready for review
```
