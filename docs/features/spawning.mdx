---
title: "Agent Spawning"
description: "Spawn PTY workers and headless agents from the SDK"
---

# Agent Spawning

The SDK spawns agent processes through the broker. Each agent runs as a separate process managed by the broker, with full lifecycle control from your code.

## Spawn Methods

### Provider shorthand (high-level)

The `AgentRelay` facade provides shorthand spawners for common providers:

```typescript
import { AgentRelay } from "@agent-relay/sdk";

const relay = new AgentRelay();

const codex  = await relay.codex.spawn();                        // Codex PTY
const claude = await relay.claude.spawn({ name: "Reviewer" });   // Claude PTY
const gemini = await relay.gemini.spawn({ name: "Tester" });     // Gemini PTY
```

Each shorthand spawns a PTY worker wrapping the named CLI tool.

### Custom PTY workers (high-level)

Use `spawnPty` for full control over CLI arguments and channels:

```typescript
const worker = await relay.spawnPty({
  name: "Backend",
  cli: "codex",
  args: ["--model", "gpt-4.1"],
  channels: ["backend"],
});
```

### Low-level client

The `AgentRelayClient` provides direct protocol access:

```typescript
import { AgentRelayClient } from "@agent-relay/sdk";

const client = await AgentRelayClient.start();

// PTY worker
const pty = await client.spawnPty({
  name: "Worker",
  cli: "claude",
  args: ["--dangerously-skip-permissions"],
  channels: ["general"],
});

// Headless Claude (no terminal)
const headless = await client.spawnHeadlessClaude({
  name: "Analyzer",
  args: ["--model", "sonnet"],
  channels: ["analysis"],
});
```

## Worker Runtimes

<Tabs>
  <Tab title="PTY">
    PTY workers wrap a CLI tool in a pseudo-terminal. The broker:

    - Spawns the CLI process with a PTY
    - Injects relay instructions on startup
    - Writes incoming messages to PTY stdin
    - Streams PTY output as `worker_stream` events

    **Supported CLIs:**

    | CLI | Auto-flags |
    |-----|------------|
    | `claude` | `--dangerously-skip-permissions` |
    | `codex` | `--full-auto` |
    | `gemini` | Gemini CLI defaults |
    | Any command | No auto-flags |

    PTY workers are the default for all providers.
  </Tab>

  <Tab title="Headless Claude">
    Headless Claude workers run without a terminal. The broker invokes Claude's SDK directly, providing:

    - No ANSI escape sequences
    - No PTY overhead
    - Cleaner structured input/output

    Use this when you need programmatic control over Claude without terminal interaction.

    ```typescript
    await client.spawnHeadlessClaude({
      name: "CodeReviewer",
      args: ["--model", "sonnet"],
    });
    ```
  </Tab>
</Tabs>

## Agent Lifecycle

<Steps>
  <Step title="Spawn">
    The SDK sends a `spawn_agent` request to the broker. The broker creates the worker process and assigns it a PID.

    ```typescript
    const agent = await relay.codex.spawn({ name: "Worker" });
    // agent.name === "Worker"
    // agent.runtime === "pty"
    ```
  </Step>

  <Step title="Active">
    The worker is running and can send/receive messages. The broker streams worker output as `worker_stream` events and delivers incoming messages.
  </Step>

  <Step title="Release or Exit">
    The worker ends in one of two ways:

    **Released** -- You explicitly release the agent:
    ```typescript
    await agent.release();
    ```

    **Exited** -- The worker process exits on its own (task complete or crash).

    Both trigger corresponding events:
    ```typescript
    relay.onAgentReleased = (agent) => console.log(`Released: ${agent.name}`);
    relay.onAgentExited   = (agent) => console.log(`Exited: ${agent.name}`);
    ```
  </Step>
</Steps>

## Waiting for Exit

Use `waitForExit` to block until a worker finishes:

```typescript
const worker = await relay.codex.spawn({ name: "TestRunner" });

const result = await worker.waitForExit(60_000); // 60s timeout

switch (result) {
  case "exited":
    console.log("Worker finished its task");
    break;
  case "released":
    console.log("Worker was released externally");
    break;
  case "timeout":
    console.log("Timed out — releasing manually");
    await worker.release();
    break;
}
```

## Spawn Options

### AgentRelay.codex.spawn / claude.spawn / gemini.spawn

| Option | Type | Description | Default |
|--------|------|-------------|---------|
| `name` | `string` | Agent name | Provider name (e.g., "Codex") |
| `args` | `string[]` | Additional CLI arguments | `[]` |
| `channels` | `string[]` | Relaycast channels to subscribe | `["general"]` |

### AgentRelay.spawnPty

| Option | Type | Description | Default |
|--------|------|-------------|---------|
| `name` | `string` | Agent name | Required |
| `cli` | `string` | CLI command to wrap | Required |
| `args` | `string[]` | Additional CLI arguments | `[]` |
| `channels` | `string[]` | Relaycast channels | `["general"]` |

## Monitoring Workers

### Worker stream events

Monitor PTY output in real-time:

```typescript
client.onEvent((event) => {
  if (event.kind === "worker_stream") {
    // event.name — agent name
    // event.stream — "stdout" or "stderr"
    // event.chunk — raw output text
    process.stdout.write(event.chunk);
  }
});
```

### List active agents

```typescript
const agents = await relay.listAgents();
for (const agent of agents) {
  console.log(`${agent.name} runtime=${agent.runtime} channels=[${agent.channels}]`);
}
```

### Broker stderr

Monitor broker-level logs:

```typescript
const unsub = client.onBrokerStderr((line) => {
  console.log(`[broker] ${line}`);
});
```

## Error Handling

Spawn failures throw typed errors:

```typescript
import { AgentRelayProtocolError, AgentRelayProcessError } from "@agent-relay/sdk";

try {
  await relay.codex.spawn({ name: "Worker" });
} catch (err) {
  if (err instanceof AgentRelayProtocolError) {
    console.log(`Protocol error: ${err.code} — ${err.message}`);
    console.log(`Retryable: ${err.retryable}`);
  } else if (err instanceof AgentRelayProcessError) {
    console.log(`Process error: ${err.message}`);
  }
}
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Name by Role" icon="tag">
    Use descriptive names: `FrontendDev`, `TestRunner`, `Reviewer`. Avoid generic names.
  </Card>
  <Card title="Release When Done" icon="circle-check">
    Always release workers after task completion to free system resources.
  </Card>
  <Card title="Use Channels" icon="hashtag">
    Assign workers to channels matching their domain for targeted message delivery.
  </Card>
  <Card title="Monitor Output" icon="terminal">
    Subscribe to `worker_stream` events to track agent progress and catch errors early.
  </Card>
</CardGroup>
