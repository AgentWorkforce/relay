# Token Usage Tracking

## Status: RFC (Request for Comments)

## Problem Statement

When a user orchestrates multiple agents through agent-relay, they have no visibility into aggregate token consumption. Each CLI tool (Claude, Codex, Gemini, etc.) meters usage independently through its own platform, but there is no unified view across an orchestration session. A lead agent spawning 5 workers has no way to know the total cost of the operation, set budgets, or detect runaway consumption.

This is a critical primitive for production multi-agent workflows where cost control is non-negotiable.

## Goals

1. **Track token usage per agent** — input tokens, output tokens, cache reads/writes, per-turn and cumulative
2. **Aggregate usage across orchestration sessions** — a single command or API call to see total consumption
3. **CLI-agnostic design** — work across Claude, Codex, Gemini, Aider, Goose, and future CLIs
4. **Budget enforcement** — allow users to set token/cost limits that trigger warnings or hard stops
5. **Zero agent modification** — consistent with relay's core principle of output parsing, not API integration
6. **Low overhead** — tracking should not meaningfully impact agent latency or throughput

## Non-Goals

- Replacing provider-level billing (Anthropic Console, OpenAI Dashboard, etc.)
- Sub-request granularity (e.g., tracking individual tool calls within a single agent turn)
- Real-time streaming of token counts during generation (we capture post-completion)

---

## Architecture Overview

```
┌──────────────────────────────────────────────────────────┐
│                   Orchestration Session                   │
│                                                          │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐   │
│  │  Lead    │  │ Worker1 │  │ Worker2 │  │ Shadow  │   │
│  │ (Claude) │  │ (Claude)│  │ (Codex) │  │ (Claude)│   │
│  └────┬─────┘  └────┬────┘  └────┬────┘  └────┬────┘   │
│       │              │            │             │        │
│       ▼              ▼            ▼             ▼        │
│  ┌──────────────────────────────────────────────────┐   │
│  │              Usage Collector (per-wrapper)        │   │
│  │  • Output parsing (CLI-specific patterns)         │   │
│  │  • File-based reporting ($AGENT_RELAY_OUTBOX)     │   │
│  │  • API polling (where available)                  │   │
│  └──────────────────┬───────────────────────────────┘   │
│                     │                                    │
│                     ▼                                    │
│  ┌──────────────────────────────────────────────────┐   │
│  │              Usage Aggregator (daemon)             │   │
│  │  • Per-agent accumulation                         │   │
│  │  • Session-level rollups                          │   │
│  │  • Budget enforcement                             │   │
│  │  • Cost estimation                                │   │
│  └──────────────────┬───────────────────────────────┘   │
│                     │                                    │
│                     ▼                                    │
│  ┌──────────────────────────────────────────────────┐   │
│  │              Storage (SQLite / JSONL)              │   │
│  │  • token_usage table                              │   │
│  │  • Queryable by agent, session, time range        │   │
│  └──────────────────────────────────────────────────┘   │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## Data Model

### TokenUsageReport

The core data structure reported by each agent per turn or per session.

```typescript
interface TokenUsageReport {
  /** Agent name (e.g., "Worker1") */
  agentName: string;
  /** Session ID from daemon WELCOME handshake */
  sessionId: string;
  /** CLI type (claude, codex, gemini, aider, goose) */
  cli: string;
  /** Model identifier (e.g., "claude-sonnet-4", "gpt-4o") */
  model?: string;
  /** Timestamp of the report (Unix ms) */
  ts: number;
  /** Granularity of the report */
  granularity: 'turn' | 'cumulative';
  /** Token counts */
  tokens: {
    /** Tokens sent to the model (prompt) */
    input: number;
    /** Tokens generated by the model (completion) */
    output: number;
    /** Tokens read from cache (prompt caching) */
    cacheRead?: number;
    /** Tokens written to cache */
    cacheWrite?: number;
  };
  /** Estimated cost in USD (computed by relay using pricing table) */
  estimatedCostUsd?: number;
  /** Turn number within this session (for turn-level reports) */
  turnNumber?: number;
  /** Source of the data */
  source: UsageDataSource;
}

type UsageDataSource =
  | 'output_parse'    // Extracted from CLI terminal output
  | 'file_report'     // Written by agent to $AGENT_RELAY_OUTBOX/usage
  | 'api_poll'        // Retrieved via CLI-specific API
  | 'self_report'     // Agent sent via relay protocol (USAGE_REPORT message)
  | 'estimated';      // Estimated from message length when no real data available
```

### TokenUsageSummary

Aggregated view across agents and sessions.

```typescript
interface TokenUsageSummary {
  /** Scope of the summary */
  scope: 'agent' | 'session' | 'team' | 'global';
  /** Scope identifier (agent name, session ID, or team name) */
  scopeId: string;
  /** Time range */
  from: number;
  to: number;
  /** Total tokens across all agents in scope */
  totalTokens: {
    input: number;
    output: number;
    cacheRead: number;
    cacheWrite: number;
  };
  /** Total estimated cost in USD */
  totalEstimatedCostUsd: number;
  /** Breakdown by agent (when scope is session/team/global) */
  byAgent?: Array<{
    agentName: string;
    cli: string;
    model?: string;
    tokens: TokenUsageReport['tokens'];
    estimatedCostUsd: number;
    turnCount: number;
  }>;
  /** Breakdown by model (when scope is session/team/global) */
  byModel?: Array<{
    model: string;
    tokens: TokenUsageReport['tokens'];
    estimatedCostUsd: number;
  }>;
}
```

### Budget Configuration

```typescript
interface UsageBudget {
  /** Maximum total tokens (input + output) across all agents */
  maxTotalTokens?: number;
  /** Maximum estimated cost in USD */
  maxCostUsd?: number;
  /** Per-agent token limit */
  maxTokensPerAgent?: number;
  /** Per-agent cost limit */
  maxCostPerAgent?: number;
  /** Action when budget is exceeded */
  onExceeded: 'warn' | 'pause' | 'kill';
  /** Warning threshold (0-1, e.g., 0.8 = warn at 80%) */
  warningThreshold?: number;
}
```

---

## Data Collection Strategies

Agent-relay operates at the PTY layer — it wraps CLI processes and parses their output. This constrains how we collect token usage data. We use a tiered approach, from highest-fidelity to lowest.

### Tier 1: Output Parsing (Primary)

Each CLI tool prints usage information in its terminal output. The existing `OutputParser` in `packages/wrapper/src/parser.ts` already strips ANSI codes and detects relay commands. We extend it to detect usage patterns.

**Claude Code** outputs a status line at the end of each turn:
```
> Total cost: $0.42 | Input: 12,345 | Output: 3,456 | Cache read: 8,000 | Cache write: 2,000
```

And a session summary on exit:
```
Total tokens: 45,678 (input: 30,000, output: 15,678)
Total cost: $1.23
```

**Codex** outputs:
```
Tokens used: 8,234 prompt + 1,456 completion = 9,690 tokens
```

**Gemini** outputs:
```
Token count: 5,432 input, 2,100 output
```

Each CLI gets a dedicated parser module:

```typescript
// packages/wrapper/src/usage-parsers/claude.ts
interface UsageParser {
  /** CLI this parser handles */
  cli: string;
  /** Attempt to extract usage from a line of output */
  parseLine(line: string): Partial<TokenUsageReport['tokens']> | null;
  /** Attempt to extract session summary from output */
  parseSessionEnd(lines: string[]): TokenUsageReport | null;
}
```

**Advantages**: No agent modification, works today, captures real numbers.
**Limitations**: Fragile if CLI output format changes; not all CLIs report tokens.

### Tier 2: File-Based Reporting

Agents can write usage data to `$AGENT_RELAY_OUTBOX/usage`. This is consistent with the existing file-based relay protocol.

```bash
cat > $AGENT_RELAY_OUTBOX/usage << 'EOF'
KIND: usage
INPUT_TOKENS: 12345
OUTPUT_TOKENS: 3456
CACHE_READ: 8000
CACHE_WRITE: 2000
MODEL: claude-sonnet-4
TURN: 5
EOF
```

The `OutboxMonitor` (in `relay-pty/src/outbox_monitor.rs` and `packages/wrapper/`) already watches this directory. Adding a `usage` file type is a natural extension.

**Advantages**: Works for any CLI; agents can report programmatically; structured data.
**Limitations**: Requires agent awareness (needs to be instructed to write usage).

### Tier 3: Protocol-Level Reporting (USAGE_REPORT Message)

Add a new message type to the relay protocol for agents that can report usage via relay commands:

```
->relay-usage: {"input": 12345, "output": 3456, "model": "claude-sonnet-4"}
```

Or via the block format:
```
[[RELAY]]{"type":"usage","input":12345,"output":3456,"model":"claude-sonnet-4"}[[/RELAY]]
```

This adds a new `USAGE_REPORT` message type to the protocol:

```typescript
// Addition to packages/protocol/src/types.ts

export type MessageType =
  | /* ...existing types... */
  | 'USAGE_REPORT'
  | 'USAGE_QUERY'
  | 'USAGE_RESPONSE'
  | 'BUDGET_ALERT';

interface UsageReportPayload {
  tokens: {
    input: number;
    output: number;
    cacheRead?: number;
    cacheWrite?: number;
  };
  model?: string;
  turnNumber?: number;
  /** If true, these are cumulative totals (not per-turn deltas) */
  cumulative?: boolean;
}

interface UsageQueryPayload {
  /** Query scope */
  scope: 'agent' | 'session' | 'team' | 'global';
  /** Scope ID (optional, defaults to caller's scope) */
  scopeId?: string;
  /** Time range filter */
  sinceTs?: number;
  untilTs?: number;
}

interface UsageResponsePayload {
  summary: TokenUsageSummary;
}

interface BudgetAlertPayload {
  /** Which budget was triggered */
  budgetType: 'total_tokens' | 'total_cost' | 'per_agent_tokens' | 'per_agent_cost';
  /** Current value */
  currentValue: number;
  /** Budget limit */
  limitValue: number;
  /** Percentage consumed (0-1) */
  percentUsed: number;
  /** Action being taken */
  action: 'warn' | 'pause' | 'kill';
  /** Agent that triggered (for per-agent budgets) */
  agentName?: string;
}
```

**Advantages**: Real-time, structured, integrated with existing protocol.
**Limitations**: Requires agents to include usage reporting in their output.

### Tier 4: Estimation (Fallback)

When no real data is available, estimate token usage based on:
- Message body length (approximately 1 token per 4 characters for English text)
- Known model context sizes
- Message direction (relay messages captured are a lower bound on actual usage)

This is clearly marked as `source: 'estimated'` and never presented as actual usage.

---

## Storage Schema

### SQLite

New table added to the existing SQLite adapter:

```sql
CREATE TABLE IF NOT EXISTS token_usage (
  id TEXT PRIMARY KEY,
  agent_name TEXT NOT NULL,
  session_id TEXT NOT NULL,
  cli TEXT NOT NULL,
  model TEXT,
  ts INTEGER NOT NULL,
  granularity TEXT NOT NULL CHECK (granularity IN ('turn', 'cumulative')),
  input_tokens INTEGER NOT NULL DEFAULT 0,
  output_tokens INTEGER NOT NULL DEFAULT 0,
  cache_read_tokens INTEGER DEFAULT 0,
  cache_write_tokens INTEGER DEFAULT 0,
  estimated_cost_usd REAL,
  turn_number INTEGER,
  source TEXT NOT NULL,
  created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now') * 1000)
);

CREATE INDEX idx_token_usage_agent ON token_usage(agent_name);
CREATE INDEX idx_token_usage_session ON token_usage(session_id);
CREATE INDEX idx_token_usage_ts ON token_usage(ts);
```

### JSONL

Appended as structured lines to a `usage.jsonl` file:

```json
{"id":"u_abc123","agentName":"Worker1","sessionId":"s_xyz","cli":"claude","model":"claude-sonnet-4","ts":1706000000000,"granularity":"turn","tokens":{"input":12345,"output":3456,"cacheRead":8000,"cacheWrite":2000},"estimatedCostUsd":0.042,"turnNumber":5,"source":"output_parse"}
```

### StorageAdapter Extension

```typescript
interface StorageAdapter {
  // ... existing methods ...

  // Token usage tracking
  saveUsageReport?(report: TokenUsageReport): Promise<void>;
  getUsageReports?(query: UsageQuery): Promise<TokenUsageReport[]>;
  getUsageSummary?(scope: UsageSummaryScope): Promise<TokenUsageSummary>;
}

interface UsageQuery {
  agentName?: string;
  sessionId?: string;
  cli?: string;
  model?: string;
  sinceTs?: number;
  untilTs?: number;
  granularity?: 'turn' | 'cumulative';
  limit?: number;
}

interface UsageSummaryScope {
  scope: 'agent' | 'session' | 'team' | 'global';
  scopeId?: string;
  sinceTs?: number;
  untilTs?: number;
}
```

---

## Pricing Table

A static, versioned pricing table enables cost estimation. Users can override with custom pricing.

```typescript
interface ModelPricing {
  /** Price per 1M input tokens in USD */
  inputPer1M: number;
  /** Price per 1M output tokens in USD */
  outputPer1M: number;
  /** Price per 1M cached input tokens (if applicable) */
  cacheReadPer1M?: number;
  /** Price per 1M cache write tokens (if applicable) */
  cacheWritePer1M?: number;
}

const DEFAULT_PRICING: Record<string, ModelPricing> = {
  // Claude
  'claude-sonnet-4': { inputPer1M: 3.00, outputPer1M: 15.00, cacheReadPer1M: 0.30, cacheWritePer1M: 3.75 },
  'claude-opus-4':   { inputPer1M: 15.00, outputPer1M: 75.00, cacheReadPer1M: 1.50, cacheWritePer1M: 18.75 },
  'claude-haiku-3.5':{ inputPer1M: 0.80, outputPer1M: 4.00, cacheReadPer1M: 0.08, cacheWritePer1M: 1.00 },
  // OpenAI
  'gpt-4o':          { inputPer1M: 2.50, outputPer1M: 10.00 },
  'gpt-4o-mini':     { inputPer1M: 0.15, outputPer1M: 0.60 },
  'o3':              { inputPer1M: 10.00, outputPer1M: 40.00 },
  // Gemini
  'gemini-2.5-pro':  { inputPer1M: 1.25, outputPer1M: 10.00 },
  'gemini-2.5-flash':{ inputPer1M: 0.15, outputPer1M: 0.60 },
};
```

Users can supply a custom pricing file at `~/.agent-relay/pricing.json` or per-project at `.agent-relay/pricing.json`. Custom entries merge with (and override) defaults.

---

## CLI Interface

### `agent-relay usage` — View Usage

```bash
# Current session usage (all agents)
agent-relay usage

# Per-agent breakdown
agent-relay usage --by-agent

# Per-model breakdown
agent-relay usage --by-model

# Specific agent
agent-relay usage --agent Worker1

# Time range
agent-relay usage --since 1h
agent-relay usage --since "2026-02-06T10:00:00"

# Output formats
agent-relay usage --format table    # Default: formatted table
agent-relay usage --format json     # Machine-readable JSON
agent-relay usage --format csv      # For spreadsheets
```

**Example output:**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Token Usage Summary                                  │
├──────────┬──────────┬────────────┬─────────────┬────────────┬──────────────┤
│ Agent    │ Model    │ Input Tok  │ Output Tok  │ Cache Read │ Est. Cost    │
├──────────┼──────────┼────────────┼─────────────┼────────────┼──────────────┤
│ Lead     │ opus-4   │   45,230   │   12,450    │   30,100   │   $4.28      │
│ Worker1  │ sonnet-4 │   23,100   │    8,340    │   15,200   │   $0.20      │
│ Worker2  │ gpt-4o   │   18,500   │    5,200    │        -   │   $0.10      │
│ Shadow   │ haiku-3.5│    8,900   │    2,100    │    6,000   │   $0.02      │
├──────────┼──────────┼────────────┼─────────────┼────────────┼──────────────┤
│ TOTAL    │          │   95,730   │   28,090    │   51,300   │   $4.60      │
└──────────┴──────────┴────────────┴─────────────┴────────────┴──────────────┘
  Session: s_abc123 | Duration: 12m 34s | Source: output_parse (3), estimated (1)
```

### `agent-relay budget` — Set Budgets

```bash
# Set session budget
agent-relay budget --max-cost 10.00
agent-relay budget --max-tokens 500000
agent-relay budget --max-cost-per-agent 2.00

# Set action on budget exceeded
agent-relay budget --max-cost 10.00 --on-exceeded warn     # Default: log warning
agent-relay budget --max-cost 10.00 --on-exceeded pause    # Pause agents, notify lead
agent-relay budget --max-cost 10.00 --on-exceeded kill     # Kill all agents

# Warning threshold
agent-relay budget --max-cost 10.00 --warn-at 0.8          # Warn at 80%

# View current budget status
agent-relay budget --status
```

### `agent-relay usage --live` — Live Monitoring

```bash
# Live-updating usage table (refreshes every 5 seconds)
agent-relay usage --live
```

---

## Protocol Integration

### New Message Types

| Type | Direction | Purpose |
|------|-----------|---------|
| `USAGE_REPORT` | Agent → Daemon | Agent reports its token usage |
| `USAGE_QUERY` | Client → Daemon | Request usage summary |
| `USAGE_RESPONSE` | Daemon → Client | Usage summary response |
| `BUDGET_ALERT` | Daemon → Agent(s) | Budget threshold or limit reached |

### USAGE_REPORT Flow

```
Agent (wrapper)                     Daemon
    │                                 │
    │  ── USAGE_REPORT ──────────►    │
    │     { tokens: {...},            │
    │       model: "sonnet-4",        │
    │       source: "output_parse" }  │
    │                                 │
    │                          ┌──────┴──────┐
    │                          │ Store in DB  │
    │                          │ Check budget │
    │                          └──────┬──────┘
    │                                 │
    │  ◄── BUDGET_ALERT ─────────     │  (if threshold exceeded)
    │     { budgetType: "total_cost", │
    │       percentUsed: 0.85,        │
    │       action: "warn" }          │
    │                                 │
```

### USAGE_QUERY Flow

Same request/response pattern as existing `STATUS`, `HEALTH`, `METRICS` queries. The MCP server, dashboard, and CLI all use this to retrieve usage data.

---

## Wrapper Integration

### UsageCollector Class

A new component in `packages/wrapper/` that plugs into the existing output processing pipeline:

```typescript
// packages/wrapper/src/usage-collector.ts

class UsageCollector extends EventEmitter {
  private cli: string;
  private parser: UsageParser;
  private cumulative: TokenUsageReport['tokens'];
  private turnCount: number;

  constructor(cli: string) {
    super();
    this.cli = cli;
    this.parser = getUsageParser(cli);
    this.cumulative = { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 };
    this.turnCount = 0;
  }

  /** Called by wrapper/orchestrator on each line of agent output */
  processLine(line: string): void {
    const parsed = this.parser.parseLine(line);
    if (parsed) {
      this.turnCount++;
      this.updateCumulative(parsed);
      this.emit('usage', {
        granularity: 'turn',
        tokens: parsed,
        turnNumber: this.turnCount,
        source: 'output_parse',
      });
    }
  }

  /** Called when agent session ends */
  processSessionEnd(recentOutput: string[]): TokenUsageReport | null {
    return this.parser.parseSessionEnd(recentOutput);
  }

  /** Called when file-based report is detected */
  processFileReport(content: string): void { /* parse and emit */ }

  /** Get current cumulative totals */
  getCumulative(): TokenUsageReport['tokens'] {
    return { ...this.cumulative };
  }
}
```

### Integration Points

The `UsageCollector` hooks into existing wrapper infrastructure:

1. **RelayPtyOrchestrator**: Process each output line through `usageCollector.processLine()` alongside the existing relay command parser
2. **TmuxWrapper**: Same integration via the output polling loop
3. **OutboxMonitor**: Watch for `$AGENT_RELAY_OUTBOX/usage` files
4. **Session end detection**: On `session-end` event, call `processSessionEnd()` and send final cumulative report to daemon

---

## Daemon Integration

### UsageAggregator

A new component in `packages/daemon/` that:

1. Receives `USAGE_REPORT` messages from wrappers
2. Stores reports via `StorageAdapter.saveUsageReport()`
3. Computes summaries on-demand for `USAGE_QUERY` requests
4. Evaluates budget rules and emits `BUDGET_ALERT` when thresholds are crossed
5. Tracks per-session running totals in memory for fast budget checks

```typescript
// packages/daemon/src/usage-aggregator.ts

class UsageAggregator {
  private sessionTotals: Map<string, Map<string, TokenUsageReport['tokens']>>;
  private budget?: UsageBudget;
  private storage: StorageAdapter;

  constructor(storage: StorageAdapter, budget?: UsageBudget) { /* ... */ }

  /** Process incoming usage report */
  async handleReport(report: TokenUsageReport): Promise<BudgetAlertPayload | null> {
    await this.storage.saveUsageReport?.(report);
    this.updateSessionTotals(report);
    return this.checkBudget(report);
  }

  /** Compute summary for a query */
  async getSummary(scope: UsageSummaryScope): Promise<TokenUsageSummary> {
    return this.storage.getUsageSummary?.(scope) ?? this.computeFromReports(scope);
  }

  /** Check if budget limits are exceeded */
  private checkBudget(report: TokenUsageReport): BudgetAlertPayload | null { /* ... */ }
}
```

---

## Telemetry Events

New telemetry events (following existing PostHog patterns in `packages/telemetry/src/events.ts`):

```typescript
/** Emitted when a usage report is received */
interface UsageReportEvent {
  cli: string;
  source: UsageDataSource;
  has_cache_data: boolean;
  granularity: 'turn' | 'cumulative';
}

/** Emitted when a budget alert fires */
interface BudgetAlertEvent {
  budget_type: string;
  percent_used: number;
  action: 'warn' | 'pause' | 'kill';
}
```

---

## Dashboard Integration

The existing dashboard (served from `public/index.html` and backed by MCP tools) gains:

1. **Usage panel** — live-updating token/cost table per agent
2. **Budget bar** — visual indicator of budget consumption
3. **Cost timeline** — chart showing cumulative spend over session duration

The MCP server (`packages/mcp/`) exposes new tools:

```typescript
// New MCP tools
'relay-usage-summary'   // Get token usage summary
'relay-usage-by-agent'  // Get per-agent breakdown
'relay-set-budget'      // Configure usage budget
'relay-budget-status'   // Check current budget status
```

---

## Implementation Phases

### Phase 1: Core Infrastructure
- `TokenUsageReport` and `TokenUsageSummary` types in `packages/protocol/`
- `UsageCollector` class in `packages/wrapper/`
- Claude output parser (most common CLI, best-defined output format)
- `USAGE_REPORT` message type
- SQLite storage schema and adapter methods
- `agent-relay usage` CLI command (basic table output)

### Phase 2: Budget Enforcement
- `UsageBudget` configuration type
- `UsageAggregator` in daemon with budget checking
- `BUDGET_ALERT` message type
- `agent-relay budget` CLI command
- Warning/pause/kill actions on budget exceeded
- Pricing table with user overrides

### Phase 3: Multi-CLI Support
- Codex output parser
- Gemini output parser
- Aider / Goose output parsers
- File-based reporting (`$AGENT_RELAY_OUTBOX/usage`)
- Estimation fallback for CLIs without parseable output

### Phase 4: Observability
- `USAGE_QUERY` / `USAGE_RESPONSE` protocol messages
- MCP tools for dashboard
- Dashboard usage panel
- `agent-relay usage --live` real-time monitoring
- JSONL adapter support
- Telemetry events

---

## Open Questions

1. **Should usage data flow through the relay protocol or a side-channel?** The relay protocol path (USAGE_REPORT message) is clean but adds traffic to the daemon socket. A side-channel (e.g., writing to a shared file or SQLite directly from the wrapper) reduces daemon load but fragments the architecture.

2. **How do we handle model identification when the CLI doesn't report it?** Claude Code reports the model; Codex doesn't always. We could infer from the `cli` field in spawn config (e.g., `claude:opus` → `claude-opus-4`) using the existing `model-mapping.ts`.

3. **Should the lead agent have access to worker usage?** If the lead can query usage via relay messages, it could make cost-aware decisions (e.g., "switch Worker2 to a cheaper model"). This is powerful but adds complexity.

4. **Per-turn vs. cumulative reporting?** Per-turn is more granular but generates more data. Cumulative is simpler but loses turn-level visibility. The spec supports both — we should decide the default.

5. **How frequently should we poll / parse for usage?** Every line of output is already processed for relay commands. Adding usage parsing to the same loop is zero additional I/O. But how often should we forward reports to the daemon — every turn, or batched?

---

## Appendix: CLI Output Format Research

### Claude Code
Claude Code displays usage in the status line and session summary. Format varies by version but typically includes:
- Per-turn: input/output token counts, cost
- Session end: cumulative totals, total cost
- Available via `--output-format json` for structured data

### Codex CLI
Reports tokens at session end. Format: `Tokens used: X prompt + Y completion = Z tokens`

### Gemini CLI
Reports token counts per response. Format varies.

### Aider
Reports token usage per edit cycle with cost. Format: `Tokens: X sent, Y received. Cost: $Z`

### Goose
Token reporting varies by version and backend.
