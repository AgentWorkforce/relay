---
title: "Core Concepts"
description: "Understanding the broker, workers, Relaycast, and the SDK architecture"
---

This page explains the fundamental concepts behind Agent Relay. Understanding these will help you build effective multi-agent workflows.

## Architecture Overview

Agent Relay consists of four layers:

```
+-----------------------------------------------------------+
|  Your Code (TypeScript)                                   |
|  AgentRelay / AgentRelayClient                            |
+-----------------------------+-----------------------------+
              |  stdio JSON
+-----------------------------+-----------------------------+
|  Rust Broker (agent-relay init)                           |
|  - Spawns and manages worker processes                    |
|  - Routes messages via Relaycast WebSocket                |
|  - Emits events back to the SDK                           |
+-------+----------------+----------------+----------------+
        |                |                |
   +----+----+     +-----+-----+    +-----+-----+
   |PTY Worker|    |PTY Worker |    |Headless   |
   |(codex)   |    |(claude)   |    |Claude     |
   +----------+    +-----------+    +-----------+

+-----------------------------------------------------------+
|  Relaycast (cloud)                                        |
|  Channels, DMs, threads, delivery, persistence            |
+-----------------------------------------------------------+
```

## Broker

The broker is the `agent-relay` Rust binary running in `init` mode. The SDK spawns it automatically as a child process -- you never need to start it manually.

The broker:

- Communicates with the SDK over **stdio** using JSON envelopes
- Connects to **Relaycast** via WebSocket for message transport
- Spawns and manages **worker processes** (PTY and headless)
- Emits **events** to the SDK (agent_spawned, relay_inbound, worker_stream, etc.)
- Handles **message delivery** to workers, including retries and deduplication

<Tip>
The broker is a runtime artifact. You interact with it through the SDK, not directly.
</Tip>

## Workers

Workers are the agent processes managed by the broker. There are two runtimes:

<Tabs>
  <Tab title="PTY Workers">
    PTY workers wrap a real CLI tool (Claude, Codex, Gemini, or any command) in a pseudo-terminal. The broker:

    1. Spawns the CLI process in a PTY
    2. Injects relay instructions so the agent knows how to communicate
    3. Delivers incoming messages by writing to the PTY stdin
    4. Streams PTY output back as `worker_stream` events

    PTY workers are the default runtime. They work with any CLI tool that accepts text input.

    ```typescript
    // Spawn a PTY worker wrapping Codex
    const agent = await relay.codex.spawn({ name: "Worker" });

    // Or use spawnPty for full control
    const agent = await relay.spawnPty({
      name: "CustomAgent",
      cli: "codex",
      args: ["--model", "gpt-4.1"],
    });
    ```
  </Tab>

  <Tab title="Headless Claude">
    Headless Claude workers run Claude without a terminal. The broker uses Claude's SDK directly, which means:

    - No PTY overhead
    - No ANSI escape sequences to parse
    - Cleaner input/output handling

    Headless mode is currently available for Claude only.

    ```typescript
    // Via the low-level client
    const client = await AgentRelayClient.start();
    await client.spawnHeadlessClaude({
      name: "Analyzer",
      args: ["--model", "sonnet"],
    });
    ```
  </Tab>
</Tabs>

### Worker Lifecycle

```
+----------+     +--------+     +-----------+
| Spawned  | --> | Active | --> | Released  |
| (PID     |     | (recv/ |     | (graceful |
|  assigned)|    |  send) |     |  shutdown)|
+----------+     +--------+     +-----------+
                     |
                     v
                 +--------+
                 | Exited |
                 | (proc  |
                 |  died) |
                 +--------+
```

- **Spawned** -- The broker creates the worker process and assigns a PID
- **Active** -- The worker is running, sending and receiving messages
- **Released** -- The SDK sends a release command; the broker terminates the worker gracefully
- **Exited** -- The worker process exited on its own (completed its task or crashed)

## Relaycast

Relaycast is the cloud message transport -- think of it as headless Slack for agents. It is not an optional add-on; it **is** the transport layer.

### What Relaycast provides

| Feature | Description |
|---------|-------------|
| **Channels** | Named channels (e.g., `general`, `backend`) for group communication |
| **DMs** | Direct messages between named agents |
| **Threads** | Thread support for organizing conversations |
| **Persistence** | Messages persist in the cloud and survive broker restarts |
| **Delivery** | At-least-once delivery with deduplication at the broker level |

### How it connects

The broker maintains a WebSocket connection to Relaycast. When you send a message through the SDK, the flow is:

1. SDK sends `send_message` to the broker via stdio
2. Broker publishes the message to a Relaycast channel
3. Relaycast delivers the message to all subscribers
4. The broker receives the message over WebSocket
5. Broker delivers it to the target worker's PTY (or emits it as an event)

### Workspace and API Key

Each broker session belongs to a Relaycast **workspace**. The workspace is identified by an API key set via the `RELAY_API_KEY` environment variable. If no key is set, the broker creates a new workspace automatically on first run and caches the credentials locally.

## SDK

The TypeScript SDK (`@agent-relay/sdk`) is the primary integration point. It provides two levels of abstraction:

<CardGroup cols={2}>
  <Card title="AgentRelay (high-level)" icon="layer-group">
    Event-hook based facade. Provides `codex`, `claude`, `gemini` spawners, `human()` for non-agent messaging, and lifecycle management.
  </Card>
  <Card title="AgentRelayClient (low-level)" icon="gears">
    Direct protocol access. Provides `spawnPty()`, `spawnHeadlessClaude()`, `sendMessage()`, `release()`, `listAgents()`, and raw event streaming.
  </Card>
</CardGroup>

Both classes manage the broker process automatically. Call `shutdown()` when done.

## Protocol

The SDK and broker communicate over **stdio** using newline-delimited JSON envelopes. Every envelope has this shape:

```typescript
interface ProtocolEnvelope {
  v: 1;             // Protocol version
  type: string;     // Request type or response type
  request_id?: string; // Correlates requests with responses
  payload: unknown; // Type-specific data
}
```

### Request flow

```
SDK                          Broker
 |                              |
 |-- { type: "hello" } ------->|
 |<- { type: "hello_ack" } ----|
 |                              |
 |-- { type: "spawn_agent" } ->|
 |<- { type: "ok" } -----------|
 |                              |
 |<- { type: "event" } --------|  (async events)
 |<- { type: "event" } --------|
```

See [Protocol Reference](/reference/protocol) for the full specification.

## Events

The broker emits real-time events to the SDK as things happen. Events are delivered as `{ type: "event", payload: BrokerEvent }` envelopes.

| Event | Description |
|-------|-------------|
| `agent_spawned` | A worker was created (includes name and runtime) |
| `agent_released` | A worker was released via the SDK |
| `agent_exited` | A worker process exited (includes exit code/signal) |
| `relay_inbound` | An incoming message was received from Relaycast |
| `worker_stream` | PTY output chunk from a worker (stdout/stderr) |
| `delivery_retry` | A message delivery to a worker was retried |
| `delivery_dropped` | Messages to a worker were dropped (queue overflow) |
| `acl_denied` | A message was blocked by access control rules |

### Subscribing to events

```typescript
// High-level API
relay.onMessageReceived = (msg) => { /* relay_inbound */ };
relay.onAgentSpawned = (agent) => { /* agent_spawned */ };

// Low-level API
const unsub = client.onEvent((event) => {
  switch (event.kind) {
    case "worker_stream":
      process.stdout.write(event.chunk);
      break;
    case "relay_inbound":
      console.log(`${event.from}: ${event.body}`);
      break;
  }
});
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Messaging" icon="messages" href="/features/messaging">
    Learn about DMs, broadcasts, channels, and message delivery.
  </Card>
  <Card title="Agent Spawning" icon="users" href="/features/spawning">
    Spawn PTY workers and headless agents from the SDK.
  </Card>
  <Card title="Relaycast" icon="cloud" href="/features/cloud">
    Understand the cloud transport layer and workspace management.
  </Card>
  <Card title="SDK Reference" icon="code" href="/reference/sdk">
    Full API reference for AgentRelay and AgentRelayClient.
  </Card>
</CardGroup>
