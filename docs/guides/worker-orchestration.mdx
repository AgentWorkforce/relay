---
title: "Worker Orchestration"
description: "Manage worker agents with the coordinator pattern for parallel task execution"
---

# Worker Orchestration

Learn how to use the SDK to spawn, coordinate, and manage worker agents for parallel task execution.

## The Coordinator Pattern

An orchestrator script spawns specialized workers, distributes tasks, monitors progress, and collects results:

```
                     +--------------+
                     |  Orchestrator|
                     |  (your code) |
                     +------+-------+
                            |
              +-------------+-------------+
              |             |             |
              v             v             v
         +--------+   +--------+   +--------+
         |Worker-1|   |Worker-2|   |Worker-3|
         |(tests) |   |(backend|   |(docs)  |
         +--------+   +--------+   +--------+
```

## Basic Orchestration

```typescript
import { AgentRelay } from "@agent-relay/sdk";

const relay = new AgentRelay();

// Track completed workers
const results = new Map<string, string>();

relay.onAgentExited = (agent) => {
  results.set(agent.name, "completed");
  console.log(`${agent.name} finished (${results.size}/3)`);
};

relay.onMessageReceived = (msg) => {
  console.log(`[${msg.from}] ${msg.text}`);
};

// Spawn specialized workers
const database = await relay.claude.spawn({ name: "Database" });
const api = await relay.codex.spawn({ name: "API" });
const ui = await relay.codex.spawn({ name: "UI" });

// Wait for all workers to finish
await Promise.all([
  database.waitForExit(120_000),
  api.waitForExit(120_000),
  ui.waitForExit(120_000),
]);

console.log("All workers complete");
await relay.shutdown();
```

## Task Distribution Patterns

### Pattern 1: Decompose and Delegate

The orchestrator breaks down a complex task and assigns pieces to specialists:

```typescript
const relay = new AgentRelay();
const human = relay.human({ name: "Orchestrator" });

// Spawn specialists
const db = await relay.claude.spawn({
  name: "Database",
  channels: ["backend"],
});

const api = await relay.codex.spawn({
  name: "API",
  channels: ["backend"],
});

const ui = await relay.codex.spawn({
  name: "UI",
  channels: ["frontend"],
});

// Send tasks
await human.sendMessage({
  to: db.name,
  text: `Create users table with: id, email, password_hash, created_at.
         Use Drizzle ORM. Add unique constraint on email.`,
});

await human.sendMessage({
  to: api.name,
  text: `Implement auth endpoints: POST /auth/register, POST /auth/login, POST /auth/logout.
         Wait for Database agent to complete the schema first.`,
});

await human.sendMessage({
  to: ui.name,
  text: `Create auth UI: LoginForm, RegisterForm components.
         Add useAuth hook for state management.`,
});
```

### Pattern 2: Fan-Out / Fan-In

Distribute identical tasks across workers, then aggregate results:

```typescript
const relay = new AgentRelay();

// Spawn test runners in parallel
const runners = await Promise.all([
  relay.codex.spawn({ name: "TestUnit" }),
  relay.codex.spawn({ name: "TestIntegration" }),
  relay.codex.spawn({ name: "TestE2E" }),
]);

// Wait for all to complete
const outcomes = await Promise.all(
  runners.map(r => r.waitForExit(300_000))
);

// All done
for (let i = 0; i < runners.length; i++) {
  console.log(`${runners[i].name}: ${outcomes[i]}`);
}

await relay.shutdown();
```

### Pattern 3: Pipeline

Chain workers where each depends on the previous:

```typescript
const relay = new AgentRelay();

const stages = [
  { name: "Analyzer", cli: "claude" },
  { name: "Implementer", cli: "codex" },
  { name: "Reviewer", cli: "claude" },
];

for (const stage of stages) {
  console.log(`Starting ${stage.name}...`);
  const agent = await relay.spawnPty({
    name: stage.name,
    cli: stage.cli,
  });

  const result = await agent.waitForExit(120_000);
  if (result === "timeout") {
    console.log(`${stage.name} timed out, releasing`);
    await agent.release();
    break;
  }
  console.log(`${stage.name} finished`);
}

await relay.shutdown();
```

## Monitoring Workers

### Stream worker output

```typescript
const client = await AgentRelayClient.start();

client.onEvent((event) => {
  if (event.kind === "worker_stream") {
    process.stdout.write(`[${event.name}] ${event.chunk}`);
  }
});
```

### List active workers

```typescript
const agents = await relay.listAgents();
for (const agent of agents) {
  console.log(`${agent.name} — ${agent.runtime} — channels=[${agent.channels}]`);
}
```

### Handle delivery failures

```typescript
client.onEvent((event) => {
  if (event.kind === "delivery_retry") {
    console.warn(`Retrying delivery to ${event.name} (attempt ${event.attempts})`);
  }
  if (event.kind === "delivery_dropped") {
    console.error(`Dropped ${event.count} messages to ${event.name}: ${event.reason}`);
  }
});
```

## Error Handling

### Spawn failures

```typescript
import { AgentRelayProtocolError } from "@agent-relay/sdk";

try {
  const worker = await relay.codex.spawn({ name: "Worker" });
} catch (err) {
  if (err instanceof AgentRelayProtocolError) {
    if (err.retryable) {
      // Wait and retry
      await new Promise(r => setTimeout(r, 5000));
      const worker = await relay.codex.spawn({ name: "Worker" });
    }
  }
}
```

### Worker crashes

Handle unexpected exits through the event hook:

```typescript
relay.onAgentExited = (agent) => {
  console.log(`${agent.name} exited unexpectedly`);
  // Optionally respawn
  relay.codex.spawn({ name: agent.name });
};
```

### Timeouts

Use `waitForExit` with a timeout to prevent indefinite blocking:

```typescript
const result = await worker.waitForExit(60_000);
if (result === "timeout") {
  await worker.release();
}
```

## Complete Example: Parallel Test Suite

```typescript
import { AgentRelay, type Agent } from "@agent-relay/sdk";

async function runTestSuite() {
  const relay = new AgentRelay();
  const results = new Map<string, string>();

  relay.onAgentExited = (agent) => {
    results.set(agent.name, "passed");
  };

  relay.onMessageReceived = (msg) => {
    console.log(`[${msg.from}] ${msg.text}`);
  };

  // Spawn test runners
  const runners: Agent[] = [];
  for (const suite of ["unit", "integration", "e2e"]) {
    const runner = await relay.codex.spawn({
      name: `Test-${suite}`,
      channels: ["testing"],
    });
    runners.push(runner);
  }

  // Wait for all with timeout
  const outcomes = await Promise.all(
    runners.map(r => r.waitForExit(300_000))
  );

  // Report results
  console.log("\nTest Suite Results:");
  for (let i = 0; i < runners.length; i++) {
    const status = outcomes[i] === "exited" ? "PASS" : outcomes[i].toUpperCase();
    console.log(`  ${runners[i].name}: ${status}`);
  }

  // Clean up any remaining workers
  for (const runner of runners) {
    try { await runner.release(); } catch { /* already exited */ }
  }

  await relay.shutdown();
}

runTestSuite();
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Right-Size Workers" icon="scale-balanced">
    Spawn workers for substantial tasks (more than 5 minutes of work), not trivial ones.
  </Card>
  <Card title="Release Promptly" icon="clock">
    Release workers as soon as they complete to free system resources.
  </Card>
  <Card title="Use Timeouts" icon="hourglass">
    Always use `waitForExit` with a timeout to prevent indefinite blocking.
  </Card>
  <Card title="Monitor Events" icon="gauge">
    Subscribe to lifecycle events to track worker progress and handle failures.
  </Card>
</CardGroup>
