---
title: Worker Orchestration
description: Manage worker agents with the coordinator pattern for parallel task execution
---

# Worker Orchestration

Learn how to use a lead agent to spawn, coordinate, and manage worker agents for parallel task execution.

## The Coordinator Pattern

A lead agent acts as the coordinator, spawning specialized workers to handle subtasks in parallel:

```
+-----------------------------------------------------------------+
|                    COORDINATOR PATTERN                             |
|                                                                    |
|                        +--------+                                  |
|                        |  Lead  |                                  |
|                        |(coord) |                                  |
|                        +---+----+                                  |
|                            |                                       |
|              +-------------+-------------+                        |
|              |             |             |                        |
|              v             v             v                        |
|         +--------+   +--------+   +--------+                     |
|         |Worker-1|   |Worker-2|   |Worker-3|                     |
|         |(tests) |   |(backend|   |(docs)  |                     |
|         +--------+   +--------+   +--------+                     |
|                                                                    |
|  Lead: Decomposes tasks, delegates, collects results              |
|  Workers: Execute specific tasks, report completion               |
+-----------------------------------------------------------------+
```

## Spawning Workers

<Steps>
  <Step title="Start the lead agent">
    ```bash
    agent-relay -n Lead claude --agent lead
    ```
  </Step>

  <Step title="Spawn workers from the lead">
    Use the `relay_spawn()` MCP tool:

    ```typescript
    relay_spawn(
      name: "TestRunner",
      cli: "claude",
      task: "Run the test suite for the auth module.\nFocus on:\n- Unit tests for JWT validation\n- Integration tests for login/logout flows\n- Edge cases: expired tokens, invalid signatures"
    )
    ```

  </Step>

  <Step title="Spawn multiple workers for parallel execution">
    ```typescript
    // Spawn backend worker
    relay_spawn(
      name: "Backend",
      cli: "claude",
      task: "Implement the password reset endpoint:\n- POST /api/auth/reset-password\n- Validate token, update password hash\n- Send confirmation email"
    )
    ```

    ```typescript
    // Spawn frontend worker
    relay_spawn(
      name: "Frontend",
      cli: "claude",
      task: "Create the password reset form:\n- ResetPasswordForm component\n- Token validation on mount\n- Success/error states"
    )
    ```

  </Step>
</Steps>

## Task Distribution Patterns

### Pattern 1: Decompose and Delegate

The lead breaks down a complex task and assigns pieces to specialists:

```typescript
// Lead receives: "Implement user authentication"
// Lead decomposes and spawns workers:

// 1. Database schema
relay_spawn(
  name: "Database",
  cli: "claude",
  task: "Create users table with:\n- id, email, password_hash, created_at\n- Unique constraint on email\n- Use Drizzle ORM"
)

// 2. API endpoints
relay_spawn(
  name: "API",
  cli: "claude",
  task: "Implement auth endpoints:\n- POST /auth/register\n- POST /auth/login\n- POST /auth/logout\nWait for Database agent to complete schema first."
)

// 3. Frontend components
relay_spawn(
  name: "UI",
  cli: "claude",
  task: "Create auth UI:\n- LoginForm, RegisterForm components\n- useAuth hook for state management\n- Protected route wrapper"
)
```

### Pattern 2: Map-Reduce

Distribute identical tasks across workers, then combine results:

```typescript
// Lead spawns test runners for different modules
const modules = ["auth", "users", "billing"];
for (const module of modules) {
  relay_spawn(
    name: `Test-${module}`,
    cli: "claude",
    task: `Run tests for src/${module}/ module.\nReport: pass count, fail count, coverage percentage.`
  )
}
```

### Pattern 3: Pipeline

Chain workers where each depends on the previous:

```
Lead spawns Worker-A
    |
    +-> Worker-A completes, notifies Lead
            |
            +-> Lead spawns Worker-B with A's output
                    |
                    +-> Worker-B completes, notifies Lead
                            |
                            +-> Lead spawns Worker-C...
```

## Collecting Results

Workers report completion to the lead using the ACK/DONE protocol:

### Worker sends completion

```typescript
relay_send(
  to: "Lead",
  message: "DONE: Test suite completed\n\nResults:\n- 47 tests passed\n- 2 tests failed (see below)\n- Coverage: 87%\n\nFailed tests:\n1. auth.test.ts:45 - Token refresh edge case\n2. auth.test.ts:89 - Concurrent session handling\n\nFiles modified:\n- src/auth/__tests__/auth.test.ts\n- src/auth/__tests__/fixtures.ts"
)
```

### Lead tracks progress

The lead maintains a mental (or explicit) checklist:

```
Waiting for:
- [x] Database - Schema created
- [x] API - Endpoints implemented
- [ ] UI - Components in progress
- [ ] TestRunner - Running tests
```

## Spawn Failures and Retries

When spawning a worker with a task, the system:

1. **Attempts delivery** of the task to the CLI via socket (or stdin fallback)
2. **Retries delivery** up to 3 times (with 2s delays) if the write fails
3. **Returns result** - succeeds if delivery was confirmed by relay-pty

A periodic sweep monitors for stuck injections as an additional safety net.

### Why injection can fail

**Delivery failures** (retried automatically):

- Socket disconnected
- Write error to stdin
- relay-pty process issue

### Automatic retry behavior

```
Delivery attempt 1 -> Failed (socket error)
  | (2s delay)
Delivery attempt 2 -> Failed (write error)
  | (2s delay)
Delivery attempt 3 -> Success
  |
Return true
```

### Handling spawn failures

Even with automatic retries, spawns can still fail. Always check the result:

```typescript
const result = await relay.spawn({
  name: 'Worker-1',
  cli: 'claude',
  task: 'Implement the login feature',
});

if (!result.success) {
  console.error(`Spawn failed after 3 attempts: ${result.error}`);
  // Additional retry at caller level (optional)
  await sleep(5000);
  const retryResult = await relay.spawn({ ... });
}
```

### Additional retry strategies

<CardGroup cols={2}>

<Card title="Exponential backoff" icon="clock-rotate-left">
  Wait longer between each caller-level retry: 5s, 10s, 20s...
</Card>

<Card title="Max retries" icon="rotate">
  Limit total retries (e.g., 2 caller-level attempts) before escalating.
</Card>

<Card title="Health check first" icon="heart-pulse">
  Verify relay broker is healthy before retry.
</Card>

<Card title="Alternative CLI" icon="arrows-rotate">
  Try a different CLI variant if one keeps failing.
</Card>

</CardGroup>

### Spawn without task

Spawning an agent **without** a task always succeeds (no verification needed):

```typescript
// This always succeeds - agent waits for messages
const result = await relay.spawn({
  name: 'Listener',
  cli: 'claude',
  // No task - agent will receive work via messages
});
```

Use this pattern when you want to send the task via relay message instead:

```typescript
await relay.spawn({ name: 'Worker', cli: 'claude' });
await relay.sendMessage('Worker', 'Your task here...');
```

## Error Handling

### Worker reports failure

```typescript
relay_send(
  to: "Lead",
  message: "ERROR: Database migration failed\n\nIssue: Column type mismatch in users table\nError: \"cannot cast varchar to uuid\"\n\nAttempted:\n1. Checked existing schema\n2. Verified migration order\n\nBlocked: Need guidance on migration strategy"
)
```

### Lead handles the error

Options for the lead:

1. **Investigate and provide guidance**
2. **Spawn a specialist** (e.g., database expert)
3. **Escalate to human** (via dashboard notification)
4. **Retry with different approach**

```typescript
relay_send(
  to: "Database",
  message: "Guidance for migration error:\n\nThe existing users table uses varchar for id.\nCreate a migration that:\n1. Adds new uuid column 'new_id'\n2. Populates from existing ids (or generates new)\n3. Drops old 'id' column\n4. Renames 'new_id' to 'id'\n\nRun migrations in a transaction."
)
```

### Timeouts and stuck workers

If a worker doesn't respond:

```bash
# Check worker status
agent-relay agents

# View worker logs
agent-relay agents:logs TestRunner

# Kill unresponsive worker
agent-relay agents:kill TestRunner
```

## Releasing Workers

When a worker completes its task, release it to free resources:

```typescript
relay_release(name: "TestRunner")
```

## Example: Parallel Test Runners

A complete example of using workers to run tests in parallel:

<Steps>
  <Step title="Lead spawns test runners">
    ```typescript
    // Lead agent spawns 3 test runners
    relay_spawn(
      name: "TestUnit",
      cli: "claude",
      task: "Run unit tests: npm run test:unit\nReport results when complete."
    )

    relay_spawn(
      name: "TestIntegration",
      cli: "claude",
      task: "Run integration tests: npm run test:integration\nReport results when complete."
    )

    relay_spawn(
      name: "TestE2E",
      cli: "claude",
      task: "Run E2E tests: npm run test:e2e\nReport results when complete."
    )
    ```

  </Step>

  <Step title="Workers execute and report">
    Each worker runs its tests and sends results:

    ```typescript
    // TestUnit reports
    relay_send(
      to: "Lead",
      message: "DONE: Unit tests completed\n- 156 passed, 0 failed\n- Coverage: 92%\n- Duration: 45s"
    )
    ```

  </Step>

  <Step title="Lead aggregates results">
    After all workers report, the lead summarizes:

    ```
    Test Suite Summary:
    - Unit: 156 passed, 92% coverage
    - Integration: 48 passed, 2 failed
    - E2E: 12 passed

    Overall: 216 passed, 2 failed
    Action: Investigating integration failures...
    ```

  </Step>

  <Step title="Lead releases workers">
    ```typescript
    relay_release(name: "TestUnit")
    relay_release(name: "TestIntegration")
    relay_release(name: "TestE2E")
    ```
  </Step>
</Steps>

## Worker Limits and Resources

### Agent limits by plan

| Plan | Max Concurrent Agents |
| ---- | --------------------- |
| Free | 3                     |
| Pro  | 20                    |
| Team | 50 per user           |

### Resource considerations

Each worker consumes:

- ~50MB memory for the wrapper
- One PTY session
- API quota for the underlying CLI

### Best practices

<CardGroup cols={2}>

<Card title="Right-size your workers" icon="scale-balanced">
  Spawn workers for substantial tasks (> 5 minutes of work), not trivial ones.
</Card>

<Card title="Release promptly" icon="clock">
  Release workers as soon as they complete to free resources.
</Card>

<Card title="Batch similar work" icon="layer-group">
  Combine related small tasks into a single worker assignment.
</Card>

<Card title="Monitor active count" icon="gauge">
  Use `agent-relay agents` to track active workers and stay within limits.
</Card>

</CardGroup>

## Monitoring Workers

### List active workers

```bash
agent-relay agents
```

Output:

```
NAME           CLI     STATUS    UPTIME
Lead           claude  active    2h 15m
Backend        claude  active    45m
Frontend       claude  active    30m
TestRunner     claude  idle      5m
```

### View worker logs

```bash
# Real-time logs
agent-relay agents:logs Backend

# Last 100 lines
agent-relay agents:logs Backend --tail 100
```

### Dashboard view

The web dashboard provides a visual overview of all agents:

- Status indicators (active, idle, error)
- Recent messages
- Resource usage
- Quick actions (view logs, release)

## Advanced: Shadow Workers

Pair workers with shadow agents for oversight. Configure shadows via `.agent-relay.json` or CLI flags:

```bash
agent-relay create-agent claude \
  --name Backend \
  --shadow Reviewer \
  --shadow-role reviewer
```

Or spawn the primary and configure shadows in `.agent-relay.json`:

```typescript
relay_spawn(
  name: "Backend",
  cli: "claude",
  task: "Implement the password reset endpoint."
)
```

The shadow agent (Reviewer) monitors Backend's work and provides feedback when code is written.
