---
title: "Swarm Primitives"
description: "Build multi-agent swarms using Agent Relay's SDK primitives"
---

Agent Relay provides the foundational primitives that enable any swarm orchestration pattern. Unlike frameworks that impose specific architectures, Agent Relay gives you complete flexibility to design your own multi-agent systems.

## Why Primitives Over Frameworks?

| Framework | Approach | Limitation |
|-----------|----------|------------|
| OpenAI Agents | Handoff-based routing | Prescriptive flow control |
| Swarms.ai | Pre-built swarm types | Configuration-heavy |
| Strands | Self-organizing swarms | AWS ecosystem lock-in |
| **Agent Relay** | **SDK primitives** | **You design the orchestration** |

## Primitives

Every swarm pattern maps back to these SDK operations:

| Capability | Agent Relay Primitive |
|------------|----------------------|
| **Spawning** | `relay.codex.spawn()`, `relay.spawnPty()` |
| **Messaging** | `client.sendMessage()`, `agent.sendMessage()` |
| **Discovery** | `relay.listAgents()`, `client.listAgents()` |
| **Lifecycle** | `agent.release()`, `agent.waitForExit()` |
| **Events** | `relay.onMessageReceived`, `client.onEvent()` |
| **Human input** | `relay.human()` |

---

## 1. Handoffs (Task Transfer)

Transfer work between agents by sending messages with context:

```typescript
import { AgentRelay } from "@agent-relay/sdk";

const relay = new AgentRelay();

const analyzer = await relay.claude.spawn({ name: "Analyzer" });
const implementer = await relay.codex.spawn({ name: "Implementer" });

// Analyzer finishes analysis, hands off to Implementer
const human = relay.human({ name: "Orchestrator" });
await human.sendMessage({
  to: "Implementer",
  text: `Implement the following based on Analyzer's findings:
    - Add input validation to /api/users endpoint
    - Fix SQL injection in search query
    - Add rate limiting middleware`,
});
```

### Handoff Patterns

<Tabs>
  <Tab title="Explicit Routing">
    Route to specialists based on task content:

    ```typescript
    async function routeToSpecialist(task: string) {
      const agents = await relay.listAgents();
      const target = agents.find(a => a.name.toLowerCase().includes("backend"));
      if (target) {
        await target.sendMessage({ to: target.name, text: task });
      }
    }
    ```
  </Tab>

  <Tab title="Pipeline">
    Pass work through a sequence of agents:

    ```typescript
    const pipeline = ["Analyzer", "Implementer", "Reviewer"];

    for (const agentName of pipeline) {
      const agent = await relay.codex.spawn({ name: agentName });
      const result = await agent.waitForExit(120_000);
      if (result === "timeout") {
        await agent.release();
        break;
      }
    }
    ```
  </Tab>

  <Tab title="Fan-Out">
    Spawn multiple workers for parallel execution:

    ```typescript
    const workers = await Promise.all([
      relay.codex.spawn({ name: "TestUnit" }),
      relay.codex.spawn({ name: "TestIntegration" }),
      relay.codex.spawn({ name: "TestE2E" }),
    ]);

    // Wait for all to finish
    const results = await Promise.all(
      workers.map(w => w.waitForExit(300_000))
    );
    ```
  </Tab>
</Tabs>

---

## 2. Discovery (Agent Registry)

Find available agents dynamically:

```typescript
const agents = await relay.listAgents();

for (const agent of agents) {
  console.log(`${agent.name} — runtime=${agent.runtime}, channels=[${agent.channels}]`);
}

// Find a specific worker
const reviewer = agents.find(a => a.name === "Reviewer");
if (reviewer) {
  await reviewer.sendMessage({
    to: "Reviewer",
    text: "Code is ready for review",
  });
}
```

---

## 3. Event-Driven Coordination

React to events in real-time:

```typescript
const relay = new AgentRelay();

const completedWorkers = new Set<string>();
const totalWorkers = 3;

relay.onAgentExited = (agent) => {
  completedWorkers.add(agent.name);
  console.log(`${agent.name} finished (${completedWorkers.size}/${totalWorkers})`);

  if (completedWorkers.size === totalWorkers) {
    console.log("All workers complete — starting review phase");
    relay.claude.spawn({ name: "Reviewer" });
  }
};

relay.onMessageReceived = (msg) => {
  console.log(`[${msg.from}] ${msg.text}`);
};

// Spawn parallel workers
await relay.codex.spawn({ name: "Worker1" });
await relay.codex.spawn({ name: "Worker2" });
await relay.codex.spawn({ name: "Worker3" });
```

---

## 4. Human-in-the-Loop

Inject human decisions into the agent workflow:

```typescript
const relay = new AgentRelay();
const human = relay.human({ name: "Manager" });

// Start a worker
const worker = await relay.codex.spawn({ name: "Developer" });

// Send instructions from a human source
await human.sendMessage({
  to: worker.name,
  text: "Implement the login page. Use React and Tailwind CSS.",
});

// Monitor progress
relay.onMessageReceived = (msg) => {
  if (msg.from === worker.name) {
    console.log(`Developer update: ${msg.text}`);
    // Could prompt the actual human here and relay their response
  }
};
```

---

## Swarm Patterns

These primitives combine to enable common swarm patterns:

<CardGroup cols={2}>
  <Card title="Hierarchical" icon="sitemap" href="/guides/worker-orchestration">
    Lead coordinates specialist workers. Best for complex decomposable tasks.
  </Card>
  <Card title="Fan-Out/Fan-In" icon="arrows-split-up-and-left">
    Parallel execution with result aggregation. Best for embarrassingly parallel work.
  </Card>
  <Card title="Pipeline" icon="arrow-right-arrow-left">
    Sequential processing through agent stages. Best for multi-step workflows.
  </Card>
  <Card title="Self-Organizing" icon="users-gear">
    Agents claim tasks from a shared channel. Best for dynamic workloads.
  </Card>
</CardGroup>

### Example: Full Swarm Coordinator

```typescript
import { AgentRelay, type Agent } from "@agent-relay/sdk";

class SwarmCoordinator {
  private relay: AgentRelay;
  private workers = new Map<string, Agent>();

  constructor() {
    this.relay = new AgentRelay();

    this.relay.onAgentExited = (agent) => {
      this.workers.delete(agent.name);
      console.log(`Worker ${agent.name} finished. ${this.workers.size} remaining.`);

      if (this.workers.size === 0) {
        this.onAllComplete();
      }
    };

    this.relay.onMessageReceived = (msg) => {
      console.log(`[${msg.from}] ${msg.text}`);
    };
  }

  async spawnWorker(name: string, cli: string) {
    const agent = await this.relay.spawnPty({ name, cli });
    this.workers.set(name, agent);
    return agent;
  }

  async releaseAll() {
    for (const agent of this.workers.values()) {
      await agent.release();
    }
    this.workers.clear();
  }

  async shutdown() {
    await this.releaseAll();
    await this.relay.shutdown();
  }

  private onAllComplete() {
    console.log("All workers complete");
  }
}
```

---

## Summary

| Primitive | What It Enables |
|-----------|-----------------|
| `relay.codex.spawn()` / `spawnPty()` | Dynamic team composition |
| `client.sendMessage()` | Task delegation, handoffs |
| `agent.waitForExit()` | Pipeline sequencing |
| `relay.listAgents()` | Discovery, load balancing |
| `relay.onAgentExited` | Fan-in aggregation |
| `relay.onMessageReceived` | Event-driven coordination |
| `relay.human()` | Human-in-the-loop |

**Agent Relay gives you primitives. You build the swarm.**
