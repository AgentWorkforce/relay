---
title: Electron Integration
description: Integrate @agent-relay/sdk into Electron applications with proper process separation
---

# Electron Integration Guide

Electron's architecture requires placing the `AgentRelay` instance in the **main process** (Node.js), then exposing it to the renderer via IPC and a preload script.

## Architecture

```
+------------------+    IPC    +------------------+    Broker    +------------------+
|  Renderer        | <-------> |  Main Process    | <----------> |  Agents (PTY)    |
|  (React/Vue/etc) |           |  (AgentRelay)    |              |  claude/codex... |
+------------------+           +------------------+              +------------------+
        ^                              ^
        |                              |
        v                              v
+------------------+           +------------------+
|  window.relay    |           |  Preload Script  |
|  (exposed API)   |           |  (contextBridge) |
+------------------+           +------------------+
```

## Installation

```bash
npm install @agent-relay/sdk
```

## Main Process Setup

### `src/main/relay-service.ts`

```typescript
import { AgentRelay, type Agent, type Message, type AgentRelayOptions } from '@agent-relay/sdk';
import { ipcMain, BrowserWindow } from 'electron';

let relay: AgentRelay | null = null;

export async function initializeRelay(options: AgentRelayOptions = {}): Promise<void> {
  if (relay) return;

  relay = new AgentRelay(options);

  relay.onMessageReceived = (msg: Message) => {
    for (const win of BrowserWindow.getAllWindows()) {
      win.webContents.send('relay:message', msg);
    }
  };

  relay.onAgentSpawned = (agent: Agent) => {
    for (const win of BrowserWindow.getAllWindows()) {
      win.webContents.send('relay:agent-spawned', { name: agent.name, status: agent.status });
    }
  };

  relay.onAgentExited = (agent: Agent) => {
    for (const win of BrowserWindow.getAllWindows()) {
      win.webContents.send('relay:agent-exited', { name: agent.name, exitCode: agent.exitCode });
    }
  };
}

export async function shutdownRelay(): Promise<void> {
  if (relay) {
    await relay.shutdown();
    relay = null;
  }
}

export function registerRelayIPC(): void {
  ipcMain.handle('relay:spawn', async (_event, name: string, cli: string, task?: string) => {
    if (!relay) return { success: false, error: 'Relay not initialized' };
    try {
      const agent = await relay.spawn(name, cli, task);
      return { success: true, name: agent.name, status: agent.status };
    } catch (err) {
      return { success: false, error: String(err) };
    }
  });

  ipcMain.handle('relay:release', async (_event, name: string) => {
    if (!relay) return { success: false, error: 'Relay not initialized' };
    try {
      const agents = await relay.listAgents();
      const agent = agents.find((a) => a.name === name);
      if (!agent) return { success: false, error: 'Agent not found' };
      await agent.release();
      return { success: true };
    } catch (err) {
      return { success: false, error: String(err) };
    }
  });

  ipcMain.handle('relay:sendMessage', async (_event, to: string, text: string) => {
    if (!relay) return { success: false, error: 'Relay not initialized' };
    try {
      const human = relay.human({ name: 'renderer' });
      const msg = await human.sendMessage({ to, text });
      return { success: true, eventId: msg.eventId };
    } catch (err) {
      return { success: false, error: String(err) };
    }
  });

  ipcMain.handle('relay:listAgents', async () => {
    if (!relay) return { success: false, error: 'Relay not initialized', agents: [] };
    try {
      const agents = await relay.listAgents();
      return {
        success: true,
        agents: agents.map((a) => ({ name: a.name, status: a.status, channels: a.channels })),
      };
    } catch (err) {
      return { success: false, error: String(err), agents: [] };
    }
  });

  ipcMain.handle('relay:broadcast', async (_event, text: string) => {
    if (!relay) return { success: false, error: 'Relay not initialized' };
    try {
      await relay.broadcast(text);
      return { success: true };
    } catch (err) {
      return { success: false, error: String(err) };
    }
  });
}
```

### `src/main/index.ts`

```typescript
import { app, BrowserWindow } from 'electron';
import path from 'node:path';
import { initializeRelay, shutdownRelay, registerRelayIPC } from './relay-service';

let mainWindow: BrowserWindow | null = null;

async function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  await mainWindow.loadFile('index.html');
}

app.whenReady().then(async () => {
  registerRelayIPC();
  await createWindow();

  await initializeRelay({
    cwd: process.cwd(),
  });
});

app.on('before-quit', (event) => {
  event.preventDefault();
  shutdownRelay()
    .then(() => app.exit(0))
    .catch(() => app.exit(1));
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});
```

## Preload Script

### `src/main/preload.ts`

```typescript
import { contextBridge, ipcRenderer } from 'electron';

export interface RelayAPI {
  spawn: (name: string, cli: string, task?: string) => Promise<{ success: boolean; name?: string; error?: string }>;
  release: (name: string) => Promise<{ success: boolean; error?: string }>;
  sendMessage: (to: string, text: string) => Promise<{ success: boolean; eventId?: string; error?: string }>;
  broadcast: (text: string) => Promise<{ success: boolean; error?: string }>;
  listAgents: () => Promise<{ success: boolean; agents: { name: string; status: string; channels: string[] }[]; error?: string }>;
  onMessage: (cb: (msg: { from: string; to: string; text: string; eventId: string }) => void) => () => void;
  onAgentSpawned: (cb: (data: { name: string; status: string }) => void) => () => void;
  onAgentExited: (cb: (data: { name: string; exitCode?: number }) => void) => () => void;
}

contextBridge.exposeInMainWorld('relay', {
  spawn: (name, cli, task) => ipcRenderer.invoke('relay:spawn', name, cli, task),
  release: (name) => ipcRenderer.invoke('relay:release', name),
  sendMessage: (to, text) => ipcRenderer.invoke('relay:sendMessage', to, text),
  broadcast: (text) => ipcRenderer.invoke('relay:broadcast', text),
  listAgents: () => ipcRenderer.invoke('relay:listAgents'),

  onMessage: (cb) => {
    const listener = (_e: unknown, data: unknown) => cb(data as Parameters<typeof cb>[0]);
    ipcRenderer.on('relay:message', listener);
    return () => ipcRenderer.removeListener('relay:message', listener);
  },

  onAgentSpawned: (cb) => {
    const listener = (_e: unknown, data: unknown) => cb(data as Parameters<typeof cb>[0]);
    ipcRenderer.on('relay:agent-spawned', listener);
    return () => ipcRenderer.removeListener('relay:agent-spawned', listener);
  },

  onAgentExited: (cb) => {
    const listener = (_e: unknown, data: unknown) => cb(data as Parameters<typeof cb>[0]);
    ipcRenderer.on('relay:agent-exited', listener);
    return () => ipcRenderer.removeListener('relay:agent-exited', listener);
  },
} satisfies RelayAPI);
```

## Renderer Usage

### TypeScript Declaration

```typescript
// src/renderer/types/relay.d.ts
import type { RelayAPI } from '../../main/preload';

declare global {
  interface Window {
    relay: RelayAPI;
  }
}
export {};
```

### React Hook

```typescript
// src/renderer/hooks/useRelay.ts
import { useState, useEffect, useCallback } from 'react';

export function useRelay() {
  const [agents, setAgents] = useState<{ name: string; status: string }[]>([]);
  const [messages, setMessages] = useState<{ from: string; text: string; ts: number }[]>([]);

  useEffect(() => {
    window.relay.listAgents().then((r) => {
      if (r.success) setAgents(r.agents);
    });

    const unsubMessage = window.relay.onMessage((msg) => {
      setMessages((prev) => [...prev, { from: msg.from, text: msg.text, ts: Date.now() }]);
    });

    const unsubSpawned = window.relay.onAgentSpawned(({ name, status }) => {
      setAgents((prev) => [...prev.filter((a) => a.name !== name), { name, status }]);
    });

    const unsubExited = window.relay.onAgentExited(({ name }) => {
      setAgents((prev) => prev.filter((a) => a.name !== name));
    });

    return () => {
      unsubMessage();
      unsubSpawned();
      unsubExited();
    };
  }, []);

  const spawnAgent = useCallback(async (name: string, cli: string, task?: string) => {
    const result = await window.relay.spawn(name, cli, task);
    if (!result.success) throw new Error(result.error);
    return result;
  }, []);

  const sendMessage = useCallback(async (to: string, text: string) => {
    return window.relay.sendMessage(to, text);
  }, []);

  return { agents, messages, spawnAgent, sendMessage };
}
```

## Key Points

1. **Main process only** — `AgentRelay` uses Node.js internals; never instantiate it in the renderer
2. **IPC bridge** — use `ipcMain.handle()` and `ipcRenderer.invoke()` for all relay operations
3. **Context isolation** — always use `contextBridge.exposeInMainWorld()`, never `nodeIntegration: true`
4. **Lifecycle** — call `relay.shutdown()` before `app.quit()` so agents are cleanly released
5. **Event forwarding** — forward relay events to renderer windows via `webContents.send()`
